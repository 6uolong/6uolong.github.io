<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on huolong blog</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on huolong blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Frida检测</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/frida%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/frida%E6%A3%80%E6%B5%8B/</guid>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;直接检测frida文件，frida文件一般会放在/data/local/tmp目录下，可以直接查找该目录下的文件判断是否存在frida。较老版本的frida会在运行后在当前目录下释放一个名为re.frida.server的文件，不过新版本已经改进了这一问题。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;识别指定端口，frida server启动后默认会在27042端口监听。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;检测ptrace状态，frida是基于ptrace技术发挥作用的，而ptrace操作是独占式的，故程序可以通过尝试对自身进行ptrace来检测frida。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;检测maps文件，frida（以64位为例）注入进程后会加载frida-agent-64.so，故进程可以通过访问/proc/self/maps查找是否加载该库判断frida的存在。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;检测线程status，frida注入进程后会启动多个新线程，通过查询/proc/self/task/number_for_tid/status下的线程信息判断是否被frida注入。以下为常见的frida会启动的新线程名次：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gmain：Frida 使用 Glib 库，其中的主事件循环被称为 GMainLoop。在 Frida 中，gmain 表示 GMainLoop 的线程。&lt;/li&gt;&#xA;&lt;li&gt;gdbus：GDBus 是 Glib 提供的一个用于 D-Bus 通信的库。在 Frida 中，gdbus 表示 GDBus 相关的线程。&lt;/li&gt;&#xA;&lt;li&gt;gum-js-loop：Gum 是 Frida 的运行时引擎，用于执行注入的 JavaScript 代码。gum-js-loop 表示 Gum 引擎执行 JavaScript 代码的线程。&lt;/li&gt;&#xA;&lt;li&gt;pool-frida：Frida 中的某些功能可能会使用线程池来处理任务，pool-frida 表示 Frida 中的线程池。&lt;/li&gt;&#xA;&lt;li&gt;linjector：一种用于 Android 设备的开源工具，它允许用户在运行时向 Android 应用程序注入动态链接库（DLL）文件。通过注入 DLL 文件，用户可以修改应用程序的行为、调试应用程序、监视函数调用等，这在逆向工程、安全研究和动态分析中是非常有用的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;检测native代码是否被inlinehook。inlinehook是一种代码hook技术，通常用于native层代码的控制，原理可以简单概括为修改函数代码开头的几个字节为跳转指令，跳转到一段由攻击者控制的内存执行额外的操作。因此被inlinehook代码的开头几个字节会发生变化，通过判断文件中的代码和内存中的代码开头是否发生变化可以用于检测frida。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;frida在attach进程注入动态链接库时会显式地校验ELF_magic字段，如果不对则直接报错退出，可以手动在内存中抹掉SO的magic字段，达到反调试的效果。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FILE &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;fopen(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/proc/self/maps&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (fgets(line, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(line), fp)) {     &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (strstr(line, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;linker64&amp;#34;&lt;/span&gt;) ) {           &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(strtoul(strtok(line, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;), NULL, &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)start&lt;span style=&#34;color:#f92672&#34;&gt;=*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)start&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x7f&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 抹除Magic       &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;}      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;Frida源码中多次调用somain结构体,但它在调用前不会判断是否为空，只要手动置空后Frida一附加就会崩溃。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; getsomainoff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findsym(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/system/bin/linker64&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__dl__ZL6somain&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)((&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)start&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;getsomainoff)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 修改somain指针&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Android抓包对抗</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/android%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97/</link>
      <pubDate>Sat, 20 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/android%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97/</guid>
      <description>&lt;h2 id=&#34;android抓包原理&#34;&gt;Android抓包原理&lt;/h2&gt;&#xA;&lt;p&gt;Android抓包的原理其实和中间人攻击的原理差不多，用下面一张图概括一下：&#xA;&lt;img src=&#34;%E6%8A%93%E5%8C%85%E6%B5%81%E7%A8%8B%E5%9B%BE.png&#34; alt=&#34;&#34;&gt;&#xA;经过这么一通操作后中间人与客户端建立了一个加密连接，也与服务器建立了一个加密连接，中间的流量内容是什么便一清二楚了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;反抓包第一计找代理&#34;&gt;反抓包第一计，找代理&lt;/h2&gt;&#xA;&lt;p&gt;应用想要知道自己是不是处于一个被抓包的环境，最容易的方法就是查找有没有代理的存在。&lt;/p&gt;&#xA;&lt;h3 id=&#34;检测wifi代理&#34;&gt;检测WiFi代理&lt;/h3&gt;&#xA;&lt;p&gt;通过配置WiFi代理，并将抓包软件的证书以magisk模块的方式安装到系统中，就可以抓Android应用的数据包。相关的Java层API如下:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Proxy.getDefaultHost&lt;/li&gt;&#xA;&lt;li&gt;ConnectivityManager.getDefaultProxy&lt;/li&gt;&#xA;&lt;li&gt;System.getProperty(&amp;ldquo;http.proxyHost&amp;rdquo;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private void getWiFiProxyStatus() {  &#xA;    ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);  &#xA;    NetworkInfo activeNetworkInfo = cm.getActiveNetworkInfo();  &#xA;    if(activeNetworkInfo!=null &amp;amp;&amp;amp;activeNetworkInfo.isConnected())  &#xA;    {  &#xA;        Log.d(TAG, &amp;#34;getWiFiProxyStatus: &amp;#34;+ activeNetworkInfo.getTypeName());  &#xA;        Log.d(TAG, &amp;#34;getWiFiProxyStatus: Host: &amp;#34; + Proxy.getDefaultHost()+ &amp;#34; Port: &amp;#34; +Proxy.getDefaultPort());  &#xA;        if(cm.getDefaultProxy() != null)  &#xA;            Log.d(TAG, &amp;#34;getWiFiProxyStatus: Host: &amp;#34; + cm.getDefaultProxy().getHost() + &amp;#34; Port: &amp;#34; + cm.getDefaultProxy().getPort());  &#xA;        Log.d(TAG, &amp;#34;getWiFiProxyStatus: Host: &amp;#34;+ System.getProperty(&amp;#34;http.proxyHost&amp;#34;)+&amp;#34; Port: &amp;#34;+ System.getProperty(&amp;#34;http.proxyPort&amp;#34;));  &#xA;    }  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是第一种方法和第三种方法其实是重复的，&lt;code&gt;Proxy.getDefaultHost&lt;/code&gt;方法内部其实调用了&lt;code&gt;System.getProperty(&amp;quot;http.proxyHost&amp;quot;)&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;检测vpn存在&#34;&gt;检测VPN存在&lt;/h3&gt;&#xA;&lt;p&gt;除了通过配置WiFi代理进行抓包，很多情况下还会通过VPN协议将流量发送到中间人进行抓包，因此检测VPN是否存在也是一种反抓包的方法。相关的Java层API如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ConnectivityManager.getNetworkInfo(17).isConnected()&lt;/li&gt;&#xA;&lt;li&gt;ConnectivityManager.getNetworkCapabilities(cm.getActiveNetwork()).hasTransport(NetworkCapabilities.TRANSPORT_VPN)&lt;/li&gt;&#xA;&lt;li&gt;ConnectivityManager.getActiveNetworkInfo().getType()==cm.TYPE_VPN&lt;/li&gt;&#xA;&lt;li&gt;NetworkInterface.getNetworkInterfaces()&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private void getVPNStatus() {  &#xA;    ConnectivityManager cm = (ConnectivityManager) getSystemService(Service.CONNECTIVITY_SERVICE);  &#xA;    Log.d(TAG, &amp;#34;getVPNStatus: &amp;#34;+ cm.getNetworkInfo(17).isConnected());  &#xA;    Log.d(TAG, &amp;#34;getVPNStatus: Transport VPN: &amp;#34; + cm.getNetworkCapabilities(cm.getActiveNetwork()).hasTransport(NetworkCapabilities.TRANSPORT_VPN));  &#xA;    Log.d(TAG, &amp;#34;getVPNStatus: TYPE_VPN: &amp;#34;+ (cm.getActiveNetworkInfo().getType()==cm.TYPE_VPN));  &#xA;  &#xA;    try {  &#xA;        Enumeration&amp;lt;NetworkInterface&amp;gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();  &#xA;&#x9;&#x9;  \\ 枚举网卡，如果存在tun0或ppp0，可能存在VPN&#xA;        while (networkInterfaces.hasMoreElements()) {  &#xA;            NetworkInterface networkInterface = networkInterfaces.nextElement();  &#xA;            if(networkInterface.toString().contains(&amp;#34;ppp&amp;#34;) || networkInterface.toString().contains(&amp;#34;tun&amp;#34;))  &#xA;                Log.d(TAG, &amp;#34;getVPNStatus: networkInterface: true&amp;#34;);  &#xA;        }  &#xA;    } catch (Exception e) {  &#xA;        e.printStackTrace();  &#xA;    }  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;反抓包第二计判证书&#34;&gt;反抓包第二计，判证书&lt;/h2&gt;&#xA;&lt;p&gt;在Android抓包原理图中我们可以发现，中间人会将自己的证书发给客户端，客户端可以通过判断证书的合法性来判断是否处于被抓包的状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于雪崩猜想的混淆构造</title>
      <link>http://localhost:1313/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%9F%BA%E4%BA%8E%E9%9B%AA%E5%B4%A9%E7%8C%9C%E6%83%B3%E7%9A%84%E6%B7%B7%E6%B7%86%E6%9E%84%E9%80%A0/</link>
      <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%9F%BA%E4%BA%8E%E9%9B%AA%E5%B4%A9%E7%8C%9C%E6%83%B3%E7%9A%84%E6%B7%B7%E6%B7%86%E6%9E%84%E9%80%A0/</guid>
      <description>&lt;h2 id=&#34;符号执行&#34;&gt;符号执行&lt;/h2&gt;&#xA;&lt;p&gt;定义：一种程序分析技术，采用抽象的符号代替精确值作为程序输入变量，通过约束求解器得出每个路径抽象的输出结果。（解方程）&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;静态符号执行：不执行程序，将所有输入符号化。&lt;/li&gt;&#xA;&lt;li&gt;动态（混合）符号执行：尽可能地执行程序，尽可能少地引入符号变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;分析流程大致如下：&#xA;&lt;img src=&#34;%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;极简示例&#34;&gt;极简示例&lt;/h3&gt;&#xA;&lt;p&gt;将下列C++源代码编译，并用符号执行框架angr进行分析。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;iostream&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; choice;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; choice;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(choice &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right path&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wrong path&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;找到right path的约束条件为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;In [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]: simgr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;explore(find&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x401208&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Out[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]: &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;SimulationManager &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; active, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; found&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;In [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]: simgr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;found[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;solver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;constraints&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Out[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]: [&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Bool (LShR((condition_56_32), &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1f&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;LShR操作表示逻辑右移，化简该条件可知约束为choice &amp;gt;= 0&lt;/p&gt;&#xA;&lt;h3 id=&#34;符号执行框架组成&#34;&gt;符号执行框架组成&lt;/h3&gt;&#xA;&lt;p&gt;符号执行框架有很多，常用的有angr、klee、triton这三个。它们大都由以下几部分组成：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;文件加载器&lt;/li&gt;&#xA;&lt;li&gt;中间语言转换接口&lt;/li&gt;&#xA;&lt;li&gt;约束求解器（比如z3）&lt;/li&gt;&#xA;&lt;li&gt;模拟执行引擎（动态分析需要）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;angr框架v9238&#34;&gt;angr框架（v9.2.38）&lt;/h3&gt;&#xA;&lt;p&gt;angr是一个支持多架构的二进制文件动态符号执行分析工具&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;simgr.use_technique&lt;/td&gt;&#xA;          &lt;td&gt;simgr.explore&lt;/td&gt;&#xA;          &lt;td&gt;simgr.step&lt;/td&gt;&#xA;          &lt;td&gt;simgr.run&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;在分析过程中使用指定的分析方法（默认为广度优先搜索）。&lt;/td&gt;&#xA;          &lt;td&gt;接收一个地址，输出到达该地址时程序的状态（默认找到一条路径就返回）。&lt;/td&gt;&#xA;          &lt;td&gt;以块或函数为最小单位模拟执行一步。&lt;/td&gt;&#xA;          &lt;td&gt;按照设定的分析方法执行直到分析完毕。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;angr中常用的约束收集策略如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>从零开始的MBA混淆(1)</title>
      <link>http://localhost:1313/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84mba%E6%B7%B7%E6%B7%861/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84mba%E6%B7%B7%E6%B7%861/</guid>
      <description>&lt;h2 id=&#34;mba运算&#34;&gt;MBA运算&lt;/h2&gt;&#xA;&lt;p&gt;MBA运算（Mixed Boolean-Arithmetic）是一种定义在模$2^n$下的混合了布尔逻辑运算（与&amp;amp;、或|、非~、异或^）和代数运算（+、-、*、/）的运算系统。以下为一个C语言实现的MBA运算示例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, b;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; b) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; b); &lt;span style=&#34;color:#75715e&#34;&gt;// 等价于c=a+b&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线性mba&#34;&gt;线性MBA&lt;/h2&gt;&#xA;&lt;p&gt;线性MBA常用于运算混淆中，它的定义如下：&#xA;$$&#xA;\sum_{i \in I}a_i e_i (x_1,x_2,&amp;hellip;,x_t)&#xA;$$&#xA;其中$a_i$为整数，$e_i(x_1,x_2,&amp;hellip;,x_n)$为只含有布尔逻辑运算的表达式，简单举几个例子，以下的表达式都属于线性MBA：&#xA;$$&#xA;f(x,y) = (x \lor y) - (x \land y) - (x \oplus y)&#xA;\newline&#xA;f(x,y) = x-3*(x \land y)-(x \oplus y)+(\lnot y)-(\lnot(x \land y)) + 2*y&#xA;$$&lt;/p&gt;&#xA;&lt;h3 id=&#34;位独立性&#34;&gt;位独立性&lt;/h3&gt;&#xA;&lt;p&gt;线性MBA的特点是具有位独立性，即由加号相连接的每一项，只含有布尔逻辑运算，变量的每一位的运算不会影响到前一位或后一位，这就是位独立性。以int类型的变量举例来说：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; y &lt;span style=&#34;color:#75715e&#34;&gt;// 01 + 01 = 10 低位向高位进位&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; y &lt;span style=&#34;color:#75715e&#34;&gt;// 01 &amp;amp; 01 = 01 不会存在进位&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;位独立性保证了每一位的运算规律相同，使得我们可以将变量的取值空间由32bit缩小至1bit，在1bit空间对变量的取值进行枚举来构造线性MBA等式，例如：&lt;/p&gt;</description>
    </item>
    <item>
      <title>位操作杂项</title>
      <link>http://localhost:1313/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%9D%82%E9%A1%B9/</guid>
      <description>&lt;h3 id=&#34;移位和乘除法&#34;&gt;移位和乘除法&lt;/h3&gt;&#xA;&lt;p&gt;移位分为左移、逻辑右移、算术右移三种，他们和乘除法有着很密切的关系：&#xA;x &amp;laquo; n 等价于 x * 2^n，算术右移是除以2后向下取整，整除在C语言中是向0取整，在python中则是向下取整。&#xA;以C语言转为的汇编为例，除2^n的算术经常优化为右移运算加符号位：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;movl &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;ecx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sarl &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;ecx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;movl &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;edx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;shrl &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;edx &lt;span style=&#34;color:#75715e&#34;&gt;// fix: %edx=(%edx&amp;lt;0?1:0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;addl &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;edx,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax &lt;span style=&#34;color:#75715e&#34;&gt;// fix: add one if a&amp;lt;0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;sarl &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;无溢出的平均数求法&#34;&gt;无溢出的平均数求法&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ((x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// sum == carries + sum_without_carries&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;y) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ((x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要特别注意在C语言中，(x+y)/2 != x/2+y/2，等号只有在x，y中有任意一个为偶数的时候成立。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ((x&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ceil_average(x,y) == average(x,y) + ((x^y)&amp;amp;1))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;((x+y - x|y)&amp;laquo;1) == x+y-(x^y)&#xA;(x+y) == (x|y)&amp;laquo;1 - (x^y) &#xA;x+y = (x&amp;amp;y)*2 + x^y&lt;/p&gt;</description>
    </item>
    <item>
      <title>Root检测</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/root%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Mon, 03 Oct 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/root%E6%A3%80%E6%B5%8B/</guid>
      <description>&lt;h3 id=&#34;执行su指令查看结果&#34;&gt;执行su指令查看结果&lt;/h3&gt;&#xA;&lt;p&gt;安装Magisk后在/system/bin目录下会多一个可执行文件magisk和两个指向它的符号链接su和setprop，因此我们可以通过执行su指令来判断Magisk是否安装，或者通过执行which命令查看是否存在su路径，进而确定设备是否root，检测代码如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FILE *fp = nullptr;&#xA;char cmd[65536];&#xA;sprintf(cmd, &amp;#34;su 2&amp;gt;&amp;amp;1&amp;#34;); // 或者使用which su来确定&#xA;if ((fp = popen(cmd, &amp;#34;r&amp;#34;)) != nullptr)&#xA;{&#xA;    fread(cmd, 1, sizeof(cmd), fp);&#xA;    pclose(fp);&#xA;}&#xA;alog(4,&amp;#34;native&amp;#34;, &amp;#34;result: %s&amp;#34;, cmd);&#xA;if(strstr(cmd,&amp;#34;inaccessible or not found&amp;#34;) != nullptr) // 相应改成是否有输出进行判断&#xA;    return env-&amp;gt;NewStringUTF(&amp;#34;not rooted&amp;#34;);&#xA;return env-&amp;gt;NewStringUTF(&amp;#34;rooted&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用mount命令查看命名空间&#34;&gt;使用mount命令查看命名空间&lt;/h3&gt;&#xA;&lt;p&gt;magisk会使用.magisk命名空间挂载许多文件，故使用mount命令即可查看手机是否被root，检测代码如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FILE *fp = nullptr;&#xA;char cmd[65536];&#xA;sprintf(cmd, &amp;#34;mount 2&amp;gt;&amp;amp;1&amp;#34;);&#xA;if ((fp = popen(cmd, &amp;#34;r&amp;#34;)) != nullptr)&#xA;{&#xA;    fread(cmd, 1, sizeof(cmd), fp);&#xA;    pclose(fp);&#xA;}&#xA;alog(4,&amp;#34;native&amp;#34;, &amp;#34;result: %s&amp;#34;, cmd);&#xA;if(strstr(cmd,&amp;#34;magisk&amp;#34;) == nullptr) \\运行结果不含magisk则未root&#xA;    return env-&amp;gt;NewStringUTF(&amp;#34;not rooted&amp;#34;);&#xA;return env-&amp;gt;NewStringUTF(&amp;#34;rooted&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>控制流图</title>
      <link>http://localhost:1313/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE/</link>
      <pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE/</guid>
      <description>&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;p&gt;控制流图（control-flow graph）简称CFG，它使用数学中的图来表示计算机程序的执行流程。CFG中的每一个顶点对应一个程序基本块，基本块是一段中间不包含分支指令，但以分支指令结尾的代码块。CFG使用有向边来表示分支，在大多数情况下会有两个比较特殊的基本块，一个是开始块（entry block），另一个是结束块（exit block）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;可到达性&#34;&gt;可到达性&lt;/h3&gt;&#xA;&lt;p&gt;可到达性是图论中的性质，经常用在程序优化中，若某一个子图没有与包含开始块的子图相连接，那么称该子图为不可执行块，移除不可执行块不会对程序有任何影响，编译器中常见的死代码消除（dead code elimination）就是在做这件事。如果开始块执行不可到达结束块，那么程序有可能出现死循环。&lt;/p&gt;&#xA;&lt;h3 id=&#34;支配关系&#34;&gt;支配关系&lt;/h3&gt;&#xA;&lt;p&gt;若从开始块到达基本块N的所有路径，都会在到达基本块N之前先到达基本块M，则基本块M支配（dominates）基本块N，记作M dom N。&lt;/p&gt;&#xA;&lt;p&gt;从支配基本块N的所有块中去除基本块本身，其余的所有基本块都严格支配基本块N，记作M sdom N。&lt;/p&gt;&#xA;&lt;p&gt;若基本块M支配基本块N，且其中间没有任何其他基本块，则基本块M直接支配（immediately dominates）基本块N，每个基本块都会有一个直接支配者，记作 M idom N。&lt;/p&gt;&#xA;&lt;p&gt;与支配关系对应的还有后支配，即从N到控制流图结束块的所有路径均经过M，记作M pdom N。&lt;/p&gt;&#xA;&lt;p&gt;支配树（dominator tree）是描述支配关系的数据结构。&lt;/p&gt;&#xA;&lt;h3 id=&#34;规约性&#34;&gt;规约性&lt;/h3&gt;&#xA;&lt;h3 id=&#34;常见分支语句的控制流图&#34;&gt;常见分支语句的控制流图&lt;/h3&gt;&#xA;&lt;p&gt;如下图所示，其中until语句和do-while语句的控制流图相似：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;cfg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;中的重写、隐藏与重载的区别</title>
      <link>http://localhost:1313/posts/c%E5%92%8Ccpp/c&#43;&#43;%E4%B8%AD%E7%9A%84%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/c%E5%92%8Ccpp/c&#43;&#43;%E4%B8%AD%E7%9A%84%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E9%87%8D%E8%BD%BD/</guid>
      <description>&lt;h3 id=&#34;c面向对象的一些易混淆概念&#34;&gt;C++面向对象的一些易混淆概念&lt;/h3&gt;&#xA;&lt;p&gt;重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。&lt;/p&gt;&#xA;&lt;p&gt;隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数且没有被virtual关键字修饰，不管参数列表是否相同，基类函数都会被隐藏。&lt;/p&gt;&#xA;&lt;p&gt;重载：是指同一类中内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。&#xA;注:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重写和被重写的函数在不同的类中，隐藏函数和被隐藏函数在不同类中,重载和被重载的函数在同一类中.&lt;/li&gt;&#xA;&lt;li&gt;重写与被重写的函数参数列表一定相同且必须有virtual修饰，重载和被重载的函数参数列表一定不同。&lt;/li&gt;&#xA;&lt;li&gt;当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;class base&#xA;{&#xA;public:&#xA;&#x9;int x;&#xA;public:&#xA;&#x9;base()&#xA;&#x9;{&#xA;&#x9;&#x9;x = 100;&#xA;&#x9;}&#xA;&#x9;void func1()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;base::func1调用&amp;#34;&amp;lt;&amp;lt;endl;&#xA;&#x9;}&#xA;&#x9;virtual void func2()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;base::func2调用&amp;#34; &amp;lt;&amp;lt; endl;&#xA;&#x9;}&#xA;};&#xA;class sub : public base&#xA;{&#xA;public:&#xA;&#x9;int x;&#xA;public:&#xA;&#x9;sub()&#xA;&#x9;{&#xA;&#x9;&#x9;x = 200;&#xA;&#x9;}&#xA;&#x9;void func1()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;sub::func1调用&amp;#34; &amp;lt;&amp;lt; endl;&#xA;&#x9;}&#xA;&#x9;virtual void func2()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;sub::func2调用&amp;#34; &amp;lt;&amp;lt; endl;&#xA;&#x9;}&#xA;};&#xA;&#xA;int main(int argc, char** argv)&#xA;{&#xA;&#x9;sub b;&#xA;&#x9;base * p1=&amp;amp;b;&#xA;&#x9;p1-&amp;gt;func1();&#xA;&#x9;p1-&amp;gt;func2();&#xA;&#x9;cout &amp;lt;&amp;lt; p1-&amp;gt;x &amp;lt;&amp;lt; endl;&#xA;&#x9;sub* p2 = &amp;amp;b;&#xA;&#x9;p2-&amp;gt;func1();&#xA;&#x9;p2-&amp;gt;func2();&#xA;&#x9;cout &amp;lt;&amp;lt; p2-&amp;gt;x &amp;lt;&amp;lt; endl;&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果:&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;踩坑笔记</title>
      <link>http://localhost:1313/posts/c%E5%92%8Ccpp/c&#43;&#43;%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/c%E5%92%8Ccpp/c&#43;&#43;%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;vector中不能存放引用&#34;&gt;vector中不能存放引用&lt;/h3&gt;&#xA;&lt;p&gt;《C++ primer》中说过vector是不能存放引用的，原因是引用不支持一般意义上的赋值操作，而 vector中元素的两个要求是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;元素必须能赋值。&lt;/li&gt;&#xA;&lt;li&gt;元素必须能复制。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;对引用赋值会使得引用指向的对象被修改，而不是引用本身被修改。&#xA;同理在标准库提供的容器中的array、list等都不可以将引用作为容器元素，如果必须要实现类似的效果，可以将指针作为容器元素。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Frida踩坑笔记</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/frida%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/frida%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;慎用js箭头函数&#34;&gt;慎用Js箭头函数&lt;/h3&gt;&#xA;&lt;p&gt;前段时间在逆向app时候需要hook onCreate函数，需要调用父类的onCreate的方法进行初始化，此时修改函数内部逻辑时候碰到了两个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;父类的super函数如何获取&lt;/li&gt;&#xA;&lt;li&gt;使用箭头函数时候this为null&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;需要注意调用父类函数正确写法为：this.$super&#xA;此外以下使用箭头函数hook的写法是错误的，此时获取的this值为null&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Java.use(&amp;#34;com.hex.wanshiwu.v2.splash.SplashActivityV2&amp;#34;)&#xA;            .onCreate.implementation = (bundle)=&amp;gt;{&#xA;                this.$super.onCreate(bundle)&#xA;                let intent = Java.use(&amp;#34;android.content.Intent&amp;#34;)&#xA;                .$new(this,Java.use(&amp;#34;com.hex.wanshiwu.v2.main.MainActivityV2&amp;#34;).class)&#xA;                this.startActivity(intent)&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正确写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Java.use(&amp;#34;com.hex.wanshiwu.v2.splash.SplashActivityV2&amp;#34;)&#xA;            .onCreate.implementation = function(bundle){&#xA;                this.$super.onCreate(bundle)&#xA;                let intent = Java.use(&amp;#34;android.content.Intent&amp;#34;)&#xA;                .$new(this,Java.use(&amp;#34;com.hex.wanshiwu.v2.main.MainActivityV2&amp;#34;).class)&#xA;                this.startActivity(intent)&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>LLVM框架开发（二）</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%BA%8C/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%BA%8C/</guid>
      <description>&lt;h3 id=&#34;指令替换pass编写&#34;&gt;指令替换pass编写&lt;/h3&gt;&#xA;&lt;p&gt;上一节介绍了如何使用新旧PassManager进行Pass编写，本节则真正上手一个Pass的编写过程中去。&#xA;该Pass的主要目标是将加减乘除等简单运算替换为更复杂但效果等价的操作，提高逆向分析的难度。以下代码将运算a+b替换为：a-(-b)&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void subAddInst(Function &amp;amp;f)&#xA;{&#xA;    Function *tmp = &amp;amp;f;&#xA;    BinaryOperator *work = nullptr;&#xA;    // 遍历函数中的基本块&#xA;    for (Function::iterator bb = tmp-&amp;gt;begin(); bb != tmp-&amp;gt;end(); ++bb)&#xA;    {&#xA;        // 遍历基本块中的命令&#xA;        for (BasicBlock::iterator ins = bb-&amp;gt;begin(); ins != bb-&amp;gt;end(); ++ins)&#xA;        {&#xA;            if (ins-&amp;gt;isBinaryOp())&#xA;            {&#xA;                if (ins-&amp;gt;getOpcode() == Instruction::Add)&#xA;                {&#xA;                    errs() &amp;lt;&amp;lt; &amp;#34;find add op&amp;#34; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;&#xA;                    BinaryOperator *op = dyn_cast&amp;lt;BinaryOperator&amp;gt;(ins);&#xA;                    IRBuilder&amp;lt;&amp;gt; builder(op);&#xA;                    Value *negInst = builder.CreateNeg(op-&amp;gt;getOperand(1));&#xA;                    Value *newInst = builder.CreateSub(op-&amp;gt;getOperand(0), negInst);&#xA;                    op-&amp;gt;replaceAllUsesWith(newInst);&#xA;                    work = op;&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    // 注意原命令脱离基本块操作不要在迭代中实现，否则会破坏迭代结构进而报错&#xA;    work-&amp;gt;eraseFromParent();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;函数空壳化pass编写&#34;&gt;函数空壳化pass编写&lt;/h3&gt;&#xA;&lt;p&gt;恶作剧形式的一个Pass，功能为将传入的函数除了return命令以外的所有命令移除，达到该函数没有功能的作用（目前只对main函数起作用）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>编译优化</title>
      <link>http://localhost:1313/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;优化器是连接编译器前端和后端的重要部分，本文简要介绍一些常见的编译优化手段，需要注意的是编译优化本质上是对程序代码的一种转换，在大多数情况下是对程序的优化，但在某些特殊情况下并不能起到优化效果，具体应用这些优化需要考虑后端架构、程序体积等。&lt;/p&gt;&#xA;&lt;h3 id=&#34;常量折叠和常量传播&#34;&gt;常量折叠和常量传播&lt;/h3&gt;&#xA;&lt;p&gt;编译器优化中有一个指导策略，即尽量把计算时机提前，能够在编译时期计算完成的不要拖到程序执行时，常量折叠和常量传播就是对这种策略的践行。&lt;/p&gt;&#xA;&lt;p&gt;常量折叠会将只包含常量的表达式或子表达式替换为计算结果，比如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;double a, b;&#xA;a = b + 1.0 / 3.0;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;替换为：&#xA;double a, b;&#xA;a = b + 0.33333;&lt;/p&gt;&#xA;&lt;p&gt;常量传播会将值已经确定值的变量替换为具体值，例如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int x = 14;&#xA;int y = 7 - x / 2;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转换为：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int x = 14;&#xA;int y = 7 - 14 / 2;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常量折叠和常量传播经常会联合使用，常量折叠后可能会产生使用常量传播的机会，同样常量传播后可能会产生使用常量折叠的机会。&lt;/p&gt;&#xA;&lt;h3 id=&#34;函数内联&#34;&gt;函数内联&lt;/h3&gt;&#xA;&lt;p&gt;函数内联会将函数调用替换为具体的函数体代码，例如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;float square(float a) &#xA;{ return a * a;}&#xA;float x = square(1.2);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;替换为：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;float x = 1.2 * 1.2;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数内联多应用于函数调用次数少，函数体长度短的情况中。其优点如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;消除了调用、返回和参数传递的开销。&lt;/li&gt;&#xA;&lt;li&gt;如果只有一个内联函数调用，代码就会变小。&lt;/li&gt;&#xA;&lt;li&gt;函数内联破坏了函数间调用关系，一定程度上起到了代码混淆作用。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;函数内联的缺点是如果要内联的函数被多次调用，且函数体很大，那么代码体积会变大很多。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Xposed模块入门</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/xposed%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/xposed%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h3 id=&#34;编辑mainfest文件&#34;&gt;编辑Mainfest文件&lt;/h3&gt;&#xA;&lt;p&gt;在AndroidMainfest文件中Application项中加入以下数据&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;meta-data&#xA;android:name=&amp;#34;xposedmodule&amp;#34;&#xA;android:value=&amp;#34;true&amp;#34; /&amp;gt;&#xA;&#xA;&amp;lt;meta-data&#xA;android:name=&amp;#34;xposeddescription&amp;#34;&#xA;android:value=&amp;#34;xposed模块描述&amp;#34; /&amp;gt;&#xA;&#xA;&amp;lt;meta-data&#xA;android:name=&amp;#34;xposedminversion&amp;#34;&#xA;android:value=&amp;#34;82&amp;#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;插入以上数据的目的是使得Xposed框架能够知道这个apk是一个模块文件&lt;/p&gt;&#xA;&lt;h3 id=&#34;加载jar包&#34;&gt;加载jar包&lt;/h3&gt;&#xA;&lt;p&gt;1.手动添加：将jar下载到本地后自行添加。手动下载XposedBridgeApi-82.jar文件，拖放到“项目名称/app/libs/”，然后右键“Add As Library” 自行添加这个jar包。之后在build.gradle的dependencies目录下添加命令&#xA;&lt;code&gt;compileOnly files(&#39;libs\\api-82.jar&#39;)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;2.自动同步：如果网络情况允许的话，可以直接在gradle文件下的dependencies下添加：&lt;code&gt;compileOnly &#39;de.robv.android.xposed:api:82&#39;&lt;/code&gt;，这样可以免去事先下载jar包的步骤，需要注意的是随着jcenter仓库关闭，目前直接使用该配置gradle会报错，所以需要在settings.gradle配置文件中做如下配置：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;config.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;添加入口点&#34;&gt;添加入口点&lt;/h3&gt;&#xA;&lt;p&gt;没有添加入口点的xposed模块可以被xposed管理器识别，但是不可以启用，必须指明入口点，启用的方法也很简单：&lt;/p&gt;&#xA;&lt;p&gt;在\src\main目录下创建assets文件夹，在该文件夹下创建入口点文件xposed_init，内容为编写的Hook类类名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;编写主要类文件&#34;&gt;编写主要类文件&lt;/h3&gt;&#xA;&lt;p&gt;这是hook类代码的一个实例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.huol.sswcrack;&#xA;&#xA;import android.app.Activity;&#xA;import android.content.Intent;&#xA;import android.os.Bundle;&#xA;&#xA;import de.robv.android.xposed.IXposedHookLoadPackage;&#xA;import de.robv.android.xposed.XC_MethodHook;&#xA;import de.robv.android.xposed.XposedBridge;&#xA;import de.robv.android.xposed.XposedHelpers;&#xA;import de.robv.android.xposed.callbacks.XC_LoadPackage;&#xA;&#xA;public class Crack implements IXposedHookLoadPackage {&#xA;    public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {&#xA;        if (lpparam.packageName.equals(&amp;#34;com.qq.ssw1&amp;#34;)) {&#xA;            ClassLoader classLoader = lpparam.classLoader;&#xA;            XposedBridge.log(&amp;#34;Loaded app: &amp;#34; + lpparam.packageName);&#xA;            Class clazz = XposedHelpers.findClass(&amp;#34;com.qq.ssw.v2.splash.SplashActivityV2&amp;#34;, lpparam.classLoader);&#xA;            XposedHelpers.findAndHookMethod(clazz, &amp;#34;onCreate&amp;#34;, Bundle.class, new XC_MethodHook() {&#xA;                @Override&#xA;                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {&#xA;                    super.beforeHookedMethod(param);&#xA;                    Class mainActivity = XposedHelpers.findClass(&amp;#34;com.qq.ssw.v2.main.MainActivityV2&amp;#34;, lpparam.classLoader);&#xA;                    Activity activity = (Activity) param.thisObject;&#xA;                    Intent mIntent = new Intent(activity, mainActivity);&#xA;                    activity.startActivity(mIntent);&#xA;                }&#xA;            }); // 去开屏广告和不必要权限要求&#xA;            XposedHelpers.findAndHookMethod(&amp;#34;tencent.io.b&amp;#34;, classLoader, &amp;#34;i&amp;#34;, new XC_MethodHook() {&#xA;                @Override&#xA;                protected void afterHookedMethod(MethodHookParam param) throws Throwable {&#xA;                    super.afterHookedMethod(param);&#xA;                    param.setResult(true);&#xA;                }&#xA;            }); //破解会员&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Android逆向环境配置</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/android%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/android%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;h3 id=&#34;手机root权限获取&#34;&gt;手机Root权限获取&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解锁BootLoader，此处推荐小米、一加等比较容易解锁的手机，小米需要等14天才能解锁，一加到手就能解锁，且这两个牌子解锁后仍然保修。&lt;/li&gt;&#xA;&lt;li&gt;根据手机型号下载TWRP，使用fastboot刷入。&lt;/li&gt;&#xA;&lt;li&gt;到 &lt;a href=&#34;https://github.com/topjohnwu/Magisk&#34;&gt;https://github.com/topjohnwu/Magisk&lt;/a&gt; 下载Magisk框架，修改后缀为.zip文件&lt;/li&gt;&#xA;&lt;li&gt;进入Recovery，可以看到此时已经被替换为TWRP，刷入类原生ROM（比较知名的有PE、crdroid、Dotos等等，注意型号）或者AOSP，这样做是为了减少出厂系统的深度魔改造成一些难以解决的错误。&lt;/li&gt;&#xA;&lt;li&gt;找到Magisk的zip文件，刷入Magisk框架，此时便获得了Root权限&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;更加详细的教程参见 &lt;a href=&#34;https://www.bilibili.com/video/BV1BY4y1H7Mc&#34;&gt;https://www.bilibili.com/video/BV1BY4y1H7Mc&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;rodebuggable属性修改&#34;&gt;ro.debuggable属性修改&lt;/h3&gt;&#xA;&lt;p&gt;通过magisk修改（重启失效），连接电脑输入以下指令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;adb shell&#xA;su&#xA;magisk resetprop ro.debuggable 1&#xA;stop;start;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除此之外还可以使用MagiskHide Props Config模块，安装后在adb shell中输入props，按照提示将ro.debuggable改为1即可，该方法修改后即使手机重启也不会失效。&lt;/p&gt;&#xA;&lt;p&gt;通过这样的配置之后Jadx，jeb等软件就可以动态调试手机上的软件了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;lsposed框架安装&#34;&gt;lsposed框架安装&lt;/h3&gt;&#xA;&lt;p&gt;Xposed框架在很早以前就已经停止更新，目前仍然维护的Xposed实现是lsposed框架，安装过程很简单，访问 &lt;a href=&#34;https://github.com/LSPosed/LSPosed&#34;&gt;https://github.com/LSPosed/LSPosed&lt;/a&gt; 下载zip包，在magisk管理器中安装即可（可以选择riru版或者zygisk版，建议安装zygisk版本，riru已经停更，预计不久riru版本的lsposed也会停更），需要注意的是zygisk版本的lsposed框架需要打开magisk的zygisk功能支持才能正常运行，注意在magisk设置中打开。&lt;/p&gt;&#xA;&lt;p&gt;安装成功后显示如下：&#xA;&lt;img src=&#34;lsp_success.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;frida环境安装&#34;&gt;frida环境安装&lt;/h3&gt;&#xA;&lt;p&gt;这是我们分析Java层代码的主力军之一，配合Jadx等静态分析工具能够做到快速定位目标功能代码，安装和配置步骤如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先在电脑上安装Python，推荐3.8.x版本，这是目前frida支持的最新版本，之后安装frida库和frida-tools库。命令如下：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install frida&#xA;pip install frida-tools&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;在已经安装magisk的手机上安装frida是很简单的一件事，访问 &lt;a href=&#34;https://github.com/ViRb3/magisk-frida/releases&#34;&gt;https://github.com/ViRb3/magisk-frida/releases&lt;/a&gt; 获取Magiskfrida模块，在Magisk管理器中安装即可。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;测试是否安装成功只需首先将手机通过USB连接到电脑上，注意允许USB调试，之后在电脑上打开终端输入命令&lt;code&gt;frida-ps -U&lt;/code&gt;，输出结果如下即为成功：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;frida_success.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在安装frida成功的基础上，安装objection库，该库是一个基于frida的扩展，提供了无代码hook，内存漫游和主动调用等等功能，安装只需一行命令：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;pip install objection&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;另外objection还有一些扩展插件可以按需安装：&#xA;wallbreaker &lt;a href=&#34;https://github.com/hluwa/Wallbreaker&#34;&gt;https://github.com/hluwa/Wallbreaker&lt;/a&gt; 能够快捷的列出内存中的对象的字段属性，方法等等。&#xA;Frida-Dexdump &lt;a href=&#34;https://github.com/hluwa/FRIDA-DEXDump&#34;&gt;https://github.com/hluwa/FRIDA-DEXDump&lt;/a&gt; 抓取内存中的dex文件达到快速脱壳的功能。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;apktool安装&#34;&gt;apktool安装&lt;/h3&gt;&#xA;&lt;p&gt;利用apktool能够便捷解码Android apk压缩包，使我们能够修改dex，Manifest，xml等等文件并重打包。&#xA;官方网站说的很详细，安装地址如下： &lt;a href=&#34;https://ibotpeaches.github.io/Apktool/install/&#34;&gt;https://ibotpeaches.github.io/Apktool/install/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;利用apktool重打包后需要配置密钥进行应用签名，签名步骤如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先生成签名，进入JDK/bin, 输入命令 &lt;code&gt;keytool -genkeypair -keystore 密钥库名 -alias 密钥别名 -validity 天数 -keyalg RSA &lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;进入目录Android SDK/build-tools/SDK版本/zipalign.exe，使用zipalign令APK包内未压缩的数据有序排列对齐，命令如下：&lt;code&gt;zipalign -p -f -v 4 infile.apk outfile.apk&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;进入Android SDK/build-tools/SDK版本目录下，输入命令&lt;code&gt;apksigner sign --ks 密钥库名 --ks-key-alias 密钥别名 xxx.apk&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;进行应用签名后，该重打包后的应用便可以在手机上安装运行了，不过建议现在大部分apk都有各种的重打包检测（主要是用签名信息做文章），apk的持久化修改还是使用lsposed框架省事点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NT驱动框架</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;h3 id=&#34;驱动模型&#34;&gt;驱动模型&lt;/h3&gt;&#xA;&lt;p&gt;NT模型&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DriverEntry()&lt;/li&gt;&#xA;&lt;li&gt;DispathCreate()-&amp;gt;IRP_MJ_CREATE&lt;/li&gt;&#xA;&lt;li&gt;DispathRead()-&amp;gt;IRP_MJ_READ&lt;/li&gt;&#xA;&lt;li&gt;DispathWrite()-&amp;gt;IRP_MJ_WRITE&lt;/li&gt;&#xA;&lt;li&gt;DispathClose()-&amp;gt;IRP_MJ_CLOSE(FileObject引用为0)&lt;/li&gt;&#xA;&lt;li&gt;Dispathclean()-&amp;gt;IRP_MJ_CLEANUP(Handle引用为0)&lt;/li&gt;&#xA;&lt;li&gt;DispathControl()-&amp;gt;IRP_MJ_DEVICE_CONTROL&lt;/li&gt;&#xA;&lt;li&gt;DriverUnload()&#xA;IRP是IO Request Packet,是由r3层传输来的信息包装之后的产物,一种分发函数会处理相应的IRP请求,在驱动开发中,IRP本质是一个很大的结构体,分为头部和栈两部分,具体结构可在VS中看到。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;调用IoCreateDevice函数创建设备对象&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PDEVICE_OBJECT DeviceObject;&#xD;&#xA;NTSTATUS status = IoCreateDevice(DriverObject,&#xD;&#xA;     sizeof(DEVICE_EXTENSION),&#xD;&#xA;     NULL,&#xD;&#xA;     FILE_DEVICE_UNKNOWN,&#xD;&#xA;     FILE_DEVICE_SECURE_OPEN,&#xD;&#xA;     FALSE,&#xD;&#xA;     &amp;amp;DeviceObject);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个参数(DriverObject),该参数用于在驱动程序和新设备对象之间建立连接,这样I/O管理器就可以向设备发送指定的IRP。&lt;/p&gt;&#xA;&lt;p&gt;第二个参数是设备扩展结构的大小。I/O管理器自动分配这个内存,并把设备对象中的DeviceExtension指针指向这块内存。&lt;/p&gt;&#xA;&lt;p&gt;第三个参数在本例中为NULL。它可以是命名该设备对象的UNICODE_STRING串的地址。决定是否命名设备对象以及以什么名字命名还需要仔细考虑,我将在本节后面深入讨论这个问题。&lt;/p&gt;&#xA;&lt;p&gt;第四个参数(FILE_DEVICE_UNKNOWN) 是设备类型。这个值可以被设备硬件键或类键中的超越值所替代,如果这两个键都含有该参数的超越值,那么硬件键中的超越值具有更高的优先权。对于属于某个已存在类的设备,必须在这些地方指定正确的值,因为驱动程序与外围系统的交互需要依靠这个值。另外,设备对象的默认安全设置也依靠这个设备类型值。&lt;/p&gt;&#xA;&lt;p&gt;第五个参数(FILE_DEVICE_SECURE_OPEN) 为设备对象提供Characteristics标志。这些标志主要关系到块存储设备(如软盘、CDROM、Jaz等等)。未公开标志位FILE_AUTOGENERATED_DEVICE_NAME仅用于内部使用,并不是DDK文档忘记提到该标志。这个参数同样也能被硬件键或类键中的对应值超越,如果两个值都存在,那么硬件键中的超越值具有更高的优先权。&lt;/p&gt;&#xA;&lt;p&gt;第六个参数(FALSE) 指出设备是否是排斥的。通常,对于排斥设备,I/O管理器仅允许打开该设备的一个句柄。这个值同样也能被注册表中硬件键和类键中的值超越,如果两个超越值都存在,硬件键中的超越值具有更高的优先权。&lt;/p&gt;&#xA;&lt;p&gt;通常设备对象都把自己的名字放到/Device目录中。在Windows 2000中,设备的名称有两个用途。第一个用途,设备命名后,其它内核模式部件可以通过调用IoGetDeviceObjectPointer函数找到该设备,找到设备对象后,就可以向该设备的驱动程序发送IRP。&#xA;另一个用途,允许应用程序打开命名设备的句柄,这样它们就可以向驱动程序发送IRP。应用程序可以使用标准的CreateFile API打开命名设备句柄,然后用ReadFile、WriteFile,和DeviceIoControl向驱动程序发出请求。应用程序打开设备句柄时使用//./路径前缀而不是标准的UNC(统一命名约定)名称,如C:/MYFILE.CPP或//FRED/C-Drive/HISFILE.CPP。在内部,I/O管理器在执行名称搜索前自动把//./转换成/??/。为了把/??目录中的名字与名字在其它目录(例如,在/Device目录)中的对象相连接,对象管理器实现了一种称为符号连接(symbolic link)的对象。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LLVM框架开发（一）</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%B8%80/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%B8%80/</guid>
      <description>&lt;h3 id=&#34;linux下llvm环境配置&#34;&gt;Linux下LLVM环境配置&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在Ubuntu和Debian环境下，直接使用官方脚本安装，输入下面的命令直接安装LLVM14&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://apt.llvm.org/llvm.sh&#xA;chmod +x llvm.sh&#xA;sudo ./llvm.sh 14&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意安装成功后命令会带上版本号，比如命令行下输入clang会提示找不到，但是输入clang-14就可以使用。&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;使用包管理器进行安装（推荐）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install clang&#xA;sudo apt install llvm&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这种方式安装的llvm和clang输入命令时不需要加版本号即可使用，推荐使用这种方法。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从源码编译安装&#xA;暂时还没用到这种方法，按下不表。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;使用旧passmanager开发第一个pass开发&#34;&gt;使用旧PassManager开发第一个Pass开发&lt;/h3&gt;&#xA;&lt;p&gt;参考官方经典案例Hello Pass：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;llvm/Pass.h&amp;#34;&#xA;#include &amp;#34;llvm/IR/Function.h&amp;#34;&#xA;#include &amp;#34;llvm/Support/raw_ostream.h&amp;#34;&#xA;#include &amp;#34;llvm/IR/LegacyPassManager.h&amp;#34;&#xA;#include &amp;#34;llvm/Transforms/IPO/PassManagerBuilder.h&amp;#34;&#xA;&#xA;using namespace llvm;&#xA;&#xA;namespace {&#xA;  struct Hello : public FunctionPass {&#xA;    static char ID;&#xA;    Hello() : FunctionPass(ID) {}&#xA;    bool runOnFunction(Function &amp;amp;F) override {&#xA;      errs() &amp;lt;&amp;lt; &amp;#34;Hello: &amp;#34;;&#xA;      errs().write_escaped(F.getName()) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;&#xA;      return false;&#xA;    }&#xA;  };&#xA;}&#xA;&#xA;char Hello::ID = 0;&#xA;&#xA;// Register for opt&#xA;static RegisterPass&amp;lt;Hello&amp;gt; X(&amp;#34;hello&amp;#34;, &amp;#34;Hello World Pass&amp;#34;);&#xA;&#xA;// Register for clang&#xA;static RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,&#xA;  [](const PassManagerBuilder &amp;amp;Builder, legacy::PassManagerBase &amp;amp;PM) {&#xA;    PM.add(new Hello());&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果出现include文件找不到错误，请在.bashrc文件中指明LLVM头文件的路径，命令如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP详解</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h3 id=&#34;http协议初相识&#34;&gt;HTTP协议初相识&lt;/h3&gt;&#xA;&lt;p&gt;HTTP协议(超文本传输协议),将超文本标记语言(HTML)从Web服务器传送到客户端,属于应用层协议,目前使用的HTTP协议基本都是基于TCP协议的。&#xA;超文本:文本中存在超链接可以进行跳转&#xA;HTTP协议的几次版本更迭:&#xA;HTTP0.9 -&amp;gt; HTTP1.0 -&amp;gt; HTTP1.1(目前所用最多的版本) -&amp;gt; HTTP2.0 -&amp;gt; HTTP3.0(仍处于概念阶段,基于QUIC协议)&lt;/p&gt;&#xA;&lt;p&gt;TCP的三次握手:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第一次连接:客户端发送带有SYN标志(同步序列编号,是TCP/IP建立连接时使用的握手信号)的连接请求报文段,然后进入SYN-SEND状态,等待服务端的确认。&lt;/li&gt;&#xA;&lt;li&gt;第二次连接:服务端接收到客户端的SYN报文后会发送一个ACK信息进行确认,同时会发送一个SYN报文给客户端,SYN和ACK会放到一个报文段中,一并发送给客户端,此时服务端进入SYN_RECV状态。&lt;/li&gt;&#xA;&lt;li&gt;第三次连接:客户端收到后,会向服务器端发送一个ACK确认报文段,发送完毕后,客户端和服务端都进入ESTABLISHED状态,三次握手完成。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;三次握手的目的是确认双方的收发能力正常,更具体可以理解为双方都知道自己和对方的收发功能正常,三次恰好能完美地验证彼此收发功能是否正常。&lt;/p&gt;&#xA;&lt;p&gt;HTTP处理过程概述:&#xA;DNS查询以获得IP地址-&amp;gt;三次握手建立TCP连接-&amp;gt;发送HTTP请求&lt;/p&gt;&#xA;&lt;h3 id=&#34;http协议再入门&#34;&gt;HTTP协议再入门&lt;/h3&gt;&#xA;&lt;p&gt;HTTP协议的特点:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用C/S模式,由客户端向服务器发出请求,服务器做出应答&lt;/li&gt;&#xA;&lt;li&gt;简单快速,客户端发送请求时,只需要传送请求方法和路径&lt;/li&gt;&#xA;&lt;li&gt;灵活,可以传输多种类型的数据对象,传输内容类型由content-type标识&lt;/li&gt;&#xA;&lt;li&gt;无连接,限制每次连接只处理一个请求,即服务器处理完客户的请求并收到应答后会断开连接,后续发展出长连接(keep-alive)&lt;/li&gt;&#xA;&lt;li&gt;无状态,如果后续处理需要之前发送的信息,则需要重新传输,后续发展出了cookie和session部分解决了这个问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;补充一下URL和URI的区别&#xA;URI可以分为URL和URN,URN确定了东西的身份,URL提供了找到它的方式&#xA;URL是URI的一种,但并非所有URI都是URL&#xA;URI和URL最大的区别在于&amp;quot;访问机制&amp;quot;&#xA;&lt;a href=&#34;https://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;是URI,加上 http:// 后才能称为URL&lt;/p&gt;&#xA;&lt;p&gt;HTTP请求报文常用参数分析&lt;/p&gt;&#xA;&lt;p&gt;HTTP请求报文由以下四部分组成:请求行,请求头,空行,请求体(GET请求没有)&lt;/p&gt;&#xA;&lt;p&gt;响应行由请求方法、URL和HTTP协议版本3个字段组成,它们用空格分隔。比如:GET /index.html HTTP/1.1&lt;/p&gt;&#xA;&lt;p&gt;请求头的参数:&#xA;Accept:浏览器端可以接受的媒体类型,比如text/html表示接受html文档,如果服务器没有此类型资源可以返回,会返回406错误。ACCEPT:*/*表示浏览器可以处理所有类型&#xA;Accept-Encoding:浏览器申明自己接收的编码方式,通常指定压缩方法,是否支持压缩,支持什么压缩方法(gzip,deflate)&lt;br&gt;&#xA;Accept-Language:申明自己接收的语言,比如zh-CN表示中文。&#xA;Connection:表示连接状态,当该值为keep-alive时表示底层的TCP连接不会断开,客户端再次访问时会继续使用这条已建立的连接,参数值为close时,则表示需要重新建立TCP连接&#xA;Host:表示服务器的Internet主机和端口号&#xA;Referer:告诉服务器客户端是由哪个页面链接过来的&#xA;User-Agent:告诉Http服务器,客户端使用的浏览器类型和操作系统&#xA;Content-Type:说明报文内对象的媒体类型,比如:text/html和image/png&lt;/p&gt;&#xA;&lt;p&gt;HTTP响应报文与请求报文类似,大多数参数代表意义相同,分为响应行,响应头,空行,响应体四部分.&#xA;响应行由协议版本,状态码和状态描述三部分组成,比如:HTTP/1.1 200 OK&lt;/p&gt;&#xA;&lt;p&gt;HTTP请求方法详解:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;GET方法:用来请求访问已被URI标识的资源,提交数据量小,提交的信息直接包含在URL当中,也可以用来提交表单等数据,但一般并不这么做&lt;/li&gt;&#xA;&lt;li&gt;POST方法:POST方法的主要目的一般并非获取内容,而是提交数据,提交的数据被放在报文的请求体中,克服了GET方法中无法保密和数据量太小等缺点&lt;/li&gt;&#xA;&lt;li&gt;PUT方法:与POST方法十分类似,用于向服务器发送数据取代指点的原有内容,因为安全性上的缺陷,基本不用&lt;/li&gt;&#xA;&lt;li&gt;HEAD方法:类似于GET方法,只不过返回的结果没有具体内容,用于获取报头&lt;/li&gt;&#xA;&lt;li&gt;DELETE方法:请求删除指定资源,因为缺少一些验证机制,现在在一个网站中发现可以使用DELETE方法基本就是发现了漏洞&lt;/li&gt;&#xA;&lt;li&gt;OPTIONS方法:用来查询针对请求URI指定资源支持的方法&lt;/li&gt;&#xA;&lt;li&gt;TRACE方法:用来回显服务器收到的请求,用于测试和诊断,易引起攻击,很少使用&lt;/li&gt;&#xA;&lt;li&gt;CONNECT方法:开启一个客户端与所请求资源之间的通道,用在HTTP代理&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP状态码详解:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1XX:表示请求已被接受但是需要继续处理,这类响应是临时响应,只包含响应行和部分响应头信息,以空行结束,很少使用&lt;/li&gt;&#xA;&lt;li&gt;2XX:表示成功,即请求已经成功被服务器接收,理解,接受&#xA;常用的有:200 OK(接受并已处理),202 Accepted(接受但并未处理),206 Partial Content(请求部分内容)&lt;/li&gt;&#xA;&lt;li&gt;3XX:表示重定向,重定向目标会在本次响应的Location域中指明&#xA;常用的有:301 Moved Permanently(永久移动),302 Found(临时跳转),304 Not Modified(资源尚未修改,请使用缓存)&lt;/li&gt;&#xA;&lt;li&gt;4XX:表示请求错误&#xA;常用:400 Bad Request,401 Unauthorized,403 Forbidden,404 Not Found&lt;/li&gt;&#xA;&lt;li&gt;5XX:表示服务器错误&#xA;常用:500 Internal Server Error,502 Bad Gateway(充当网关或代理服务器,从远端服务器接收到一个无效请求)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;HTTP的状态管理:cookie和session&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java网络编程</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h3 id=&#34;url解析&#34;&gt;url解析&lt;/h3&gt;&#xA;&lt;p&gt;当我们在浏览器内输入一段网址的时候,比如 &lt;a href=&#34;http://www.google.com&#34;&gt;http://www.google.com&lt;/a&gt; 进行访问的时候,真实发送出去的可能并非如此,可能是&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.google.com:80/search?q=test&amp;amp;safe=strict&#34;&gt;http://www.google.com:80/search?q=test&amp;amp;safe=strict&lt;/a&gt;&#xA;协议   域名/IP地址    端口 路径   问号后为参数&lt;/p&gt;&#xA;&lt;h3 id=&#34;dns解析domain-name-system&#34;&gt;DNS解析(Domain Name System)&lt;/h3&gt;&#xA;&lt;p&gt;如果我们要访问谷歌,只需要输入域名或者IP(这个一般没人会去做)就好了,但是谷歌是相当大的,不可能只有一台服务器,我们是怎么找到它其中一台服务器的哪?这就用到了DNS解析.即将输入的域名解析为IP地址.为了说清楚域名解析的过程,我们来看看域名都包含哪些东西:&#xA;&lt;a href=&#34;https://www.google.com&#34;&gt;www.google.com&lt;/a&gt;.&#xA;. 根域名&#xA;.com  顶级域名(还有.org .edu等)&#xA;.google 次级域名(这个就比较自由了,依照自己需要发挥)&#xA;此处没有三级域名   三级域名&#xA;www  主机名(根据需求可变比如:news.163.com)&#xA;DNS解析方法主要有两种:递归和迭代&#xA;大体方向:浏览器-&amp;gt;dns客户端(本地程序)-&amp;gt;各级DNS服务器&#xA;另外一个域名是可以对应一个或多个IP的&lt;/p&gt;&#xA;&lt;h3 id=&#34;各级协议&#34;&gt;各级协议&lt;/h3&gt;&#xA;&lt;p&gt;真实网络层级分为5层(OSI七层是模型,因某些原因真实情况并不是7层):&lt;/p&gt;&#xA;&lt;p&gt;应用层(用户所接触到的应用对数据处理格式)&#xA;传输层(端口到端口的连接,同一主机上有许多程序被分配了不同的端口)&#xA;网络层(主机到主机之间的联系,发送地到目的地)&#xA;数据链路层(网卡和网卡之间信息传输,关系到mac地址,传输信息采用广播这种比较原始的方法)&#xA;物理层(过于底层,真实的物理连接,电缆光缆等等)&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;分层思想(计组第一章内容)使得大家能够各司其职,在本层做出改动只要不影响向上一层的接口,那么对于上一层来说就没有影响。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;每一层有每一层使用的协议(即数据组织格式),举例来说:&lt;/p&gt;&#xA;&lt;p&gt;应用层协议: HTTP协议(传输网页内容) SMTP(收发邮件) FTP(文件传输) DNS(域名解析)&lt;/p&gt;&#xA;&lt;p&gt;传输层协议: TCP协议(较为可靠,但是比较繁琐) UDP(不太可靠,相对简单)&lt;/p&gt;&#xA;&lt;p&gt;网络层协议: IP协议(每个主机都有一个IP)&lt;/p&gt;&#xA;&lt;p&gt;数据链路层协议: Ethernet协议 ARP(IP地址和mac地址转换)&lt;/p&gt;&#xA;&lt;p&gt;物理层: 电信号(一般没人到这步吧&amp;hellip;.)&lt;/p&gt;&#xA;&lt;p&gt;协议格式简述:&#xA;&lt;img src=&#34;protocol.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;web基础概念&#34;&gt;Web基础概念&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件架构&#xA;C/S类型:客户端/服务器端&amp;ndash;&amp;gt; QQ,360客户端&#xA;B/S类型:浏览器/服务器端&amp;ndash;&amp;gt; 各种网站&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;资源分类&#xA;静态资源:所有用户访问时得到的结果都是一样的,静态资源可以直接被浏览器解析。比如:html,css,jpg等等&#xA;动态资源:不同用户访问得到的结果可能是不一样的,浏览器无法被浏览器直接解析,必须经过服务器端处理后转换为静态资源返回给浏览器才能解析。比如:php,asp,jsp等等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;CSArch.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;网络通信三要素&#xA;IP:计算机在网络中的唯一标识&#xA;端口:应用程序监听的端口在计算机中是唯一的&#xA;传输协议:规定了数据传输的格式,比如TCP,UDP,HTTP协议&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;常见的web服务器&#xA;服务器:安装了服务器软件的计算机&#xA;服务器软件:接收用户的请求,处理请求做出回应&#xA;web服务器软件:tomcat,weblogic等等&lt;/p&gt;</description>
    </item>
    <item>
      <title>C语言零碎</title>
      <link>http://localhost:1313/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E/</guid>
      <description>&lt;h3 id=&#34;c-语言中的输入输出&#34;&gt;C 语言中的输入输出&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;gets()函数和puts()函数一起处理字符串非常方便，gets()函数会自动将最后的回车“干掉”，这样就不用担心下次输入时发现缓冲区里面有个\n了。而puts()则会自动换行，配合使用very nice！&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;for(int i=0;i&amp;lt;N;i++)&lt;/code&gt;在for中定义的i变量也只在for的作用域中生效，如果i只是为了让{}中语句重复执行几次而没有什么特殊意义，这样写是可以的。&lt;/li&gt;&#xA;&lt;li&gt;可能令人吃惊，\n在scanf格式串中不表示等待换行符，而是读取并放弃连续的空白字符。（事实上，scanf格式串中的任何空白字符都表示读取并放弃空白字符。而且，诸如%d这样的格式也会扔掉前边的空白，因此你通常根本不需要在scanf格式串中加入显式的空白。）scanf()函数有些大坑，有些非常规输入你要懂得一些缓冲区的知识才能解释，因此如果你有拿这个玩意实现一些非常规操作的话，最好掂量一下。&lt;/li&gt;&#xA;&lt;li&gt;fgets()函数和gets()函数很像，别指望这个函数读取\n，它和gets一个尿性，无非是把stdin改成了任意FILE指针指向的地址，不过虽然不能读取\n，读取空格还是可以的。fgets(string,n,stdin)与gets(string)在一定范围内是等价的。&lt;/li&gt;&#xA;&lt;li&gt;stdin,stdout,stderr就是FILE类型的指针，不过他是随着计算机系统的开启默认打开的，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。printf（）其实就是向stdout中输出，等同于fprintf（stdout，&amp;ldquo;xxxx&amp;rdquo;），perror()其实就是向stderr中输出，相当于fprintf（stderr，&amp;ldquo;xxxx&amp;rdquo;）&lt;/li&gt;&#xA;&lt;li&gt;关于缓冲区的理解：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全缓冲&#xA;内存中有一段存储区域，比如有1024个字节大小，有一个程序会从这段存储区域中读取数据。现在系统把一个文件的内容放入这个存储区，只要1024个字节都放满了，那么程序会立即来读取这1024个字节的数据。只要1024个字节没有放满，哪怕只放了1023个字节，程序都不会来读取，这就是全缓冲的意思。&lt;/li&gt;&#xA;&lt;li&gt;行缓冲&#xA;内存中有一段存储区域，比如有1024个字节大小，有一个程序会从这段存储区域中读取数据。现在系统把一个文件的内容放入这个存储区，假如放了10个字节的数据，你敲了回车键，那么程序就马上来读取了。假如放了20个字节，你敲了回车键，程序也会来读取。所以即使1024个字节没有放满，但是你敲了回车键，程序就会来读取，这个就叫做行缓冲。典型代表是标准输入(stdin)和标准输出(stdout)，scanf()的诸多坑就是因为它的存在导致。&lt;/li&gt;&#xA;&lt;li&gt;无缓冲&#xA;内存中有一段存储区域，比如有1024个字节大小，有一个程序会从这段存储区域中读取数据。现在系统把一个文件的内容放入这个存储区，刚放了1个字节，程序就马上来读取了；又放了一个字节，程序又马上来读取了，这就是没有缓冲。比如getch()函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;linux与Windows上通用的清除缓冲区的方法，我们知道在Windows下清除缓冲区的方法是fflush(stdin)，但是该方法在linux下不一定能够奏效，我们可以使用scanf(&amp;quot;%*[^\n]%&lt;em&gt;c&amp;quot;);%&lt;/em&gt;[^\n]将逐个读取缓冲区中的 &amp;lsquo;\n&amp;rsquo; 字符之前的其它字符，% 后面的 * 表示将读取的这些字符丢弃，遇到 &amp;lsquo;\n&amp;rsquo; 字符时便停止读取。此时，缓冲区中尚有一个 &amp;lsquo;\n&amp;rsquo; 字符遗留，所以后面的%*c 将读取并丢弃这个遗留的换行符，这里的星号和前面的星号作用相同。由于所有从键盘的输入都是以回车结束的，而回车会产生一个 &amp;lsquo;\n&amp;rsquo; 字符，所以将 &amp;lsquo;\n&amp;rsquo; 连同它之前的字符全部读取并丢弃之后，也就相当于清除了输入缓冲区。&lt;/li&gt;&#xA;&lt;li&gt;C语言数组的初始化：C语言会在初始化数组的时候把未赋值的元素赋值为0，注意在对字符串进行初始化的时候不要让字符串长度正好等于元素个数，否则在输出的时候可能发生错误(原因：&amp;rsquo;\0&amp;rsquo;为字符串结束的标志，因为长度和元素个数正好相等，结尾没有&amp;rsquo;\0&amp;rsquo;，系统不知道什么时候字符串结束，可能会多输出)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;格式化输出&#34;&gt;格式化输出&lt;/h3&gt;&#xA;&lt;p&gt;%n存在的内存泄漏和修改漏洞&#xA;%n可以再printf函数中对变量赋值,值的大小为printf执行到%n处打印的字符数目&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;&#xA;int main()&#xA;{&#xA;&#x9;char* p = &amp;#34;hello,world&amp;#34;;&#xA;&#x9;int len = 0;&#xA;&#x9;printf(&amp;#34;helloworld%n&amp;#34;,&amp;amp;len);&#xA;&#x9;printf(&amp;#34;%d&amp;#34;, len);&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为它能够修改内存,故从很早之前开始在VS编程中使用%n会导致程序无法运行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结构体所占内存问题&#34;&gt;结构体所占内存问题&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;&#xA;typedef struct &#xA;{&#xA;&#x9;char c1;&#xA;&#x9;long i;&#xA;&#x9;char c2;&#xA;&#x9;double f;&#xA;}a;&#xA;typedef struct&#xA;{&#xA;&#x9;char c1;&#xA;&#x9;char c2;&#xA;&#x9;long i;&#xA;&#x9;double f;&#xA;}b;&#xA;int main()&#xA;{&#xA;&#x9;printf(&amp;#34;%d %d&amp;#34;, sizeof(a),sizeof(b));&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果猜猜是什么? 24和16&#xA;结构体所占大小的两条准则:&lt;/p&gt;</description>
    </item>
    <item>
      <title>C语言预处理机制</title>
      <link>http://localhost:1313/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h3 id=&#34;宏定义&#34;&gt;宏定义&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无参数宏定义&#xA;#define PI 3.1415926&#xA;#define _WINDOWS_&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要注意的是宏只是简单的替换,宏常量没有数据类型,编译器不会对此进行检查,可能产生意想不到的错误.如果要定义常量,最好使用const定义常量.&lt;/li&gt;&#xA;&lt;li&gt;宏定义末尾不必加分号，否则连分号一并替换.&lt;/li&gt;&#xA;&lt;li&gt;预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;带参宏定义&#xA;#define MAX(x, y)     (((x) &amp;gt; (y)) ? (x) : (y))&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;宏定义时建议所有的层次都要加括号,因为预处理只是把宏展开,不加括号可能造成意想不到的后果.比如数值计算出错.&lt;/li&gt;&#xA;&lt;li&gt;带参数的宏定义可以部分替代函数的功能,相比函数的好处是用宏只会增加编译时间,不会增加内存的分配.而函数则会在栈上分配空间,占用内存.&lt;/li&gt;&#xA;&lt;li&gt;#define可以定义多条语句，以替代多行的代码，但应注意替换后的形式，避免出错。宏定义在换行时要加上一个反斜杠”\”，而且反斜杠后面直接回车，不能有空格。例子:&#xA;#define TMAX_S(type, x, y) ({ &lt;br&gt;&#xA;type _x = (x);  &lt;br&gt;&#xA;type _y = (y);  &lt;br&gt;&#xA;_x &amp;gt; _y ? _x: _y; })&#xA;这是安全版的max函数.&#xA;Gcc编译器将包含在圆括号和大括号双层括号内的复合语句看作是一个表达式，它可出现在任何允许表达式的地方；复合语句中可声明局部变量，判断循环条件等复杂处理。而表达式的最后一条语句必须是一个表达式，它的计算结果作为返回值。这样部分替代了函数的功能.&lt;/li&gt;&#xA;&lt;li&gt;取消宏定义可用#undef命令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;字符串化操作符&#34;&gt;字符串化操作符#&lt;/h3&gt;&#xA;&lt;p&gt;下面开始就是我们在课堂上没怎么见过的用法了,在C语言的宏中，#的功能是将其后面的宏参数进行字符串化操作(Stringfication)，把随后的token(标识符,或者说变量名)转化为C语言的字符串,简单说就是将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define EXAMPLE(instr) printf(&amp;#34;The input string is:%s\n&amp;#34;, #instr)&#xA;#define EXAMPLE2(instr) #instr&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;EXAMPLE(Hello);会展开为printf(&amp;ldquo;The input string is:%s\n&amp;rdquo;,&amp;ldquo;Hello&amp;rdquo;);&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;忽略传入参数名前面和后面的空格。&lt;/li&gt;&#xA;&lt;li&gt;当传入参数名间存在多个空格时，编译器会自动连接各个子字符串，每个子字符串间只以一个空格连接。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;符号连接操作符&#34;&gt;符号连接操作符##&lt;/h3&gt;&#xA;&lt;p&gt;##运算符(Token Pasting Operator)连接两个token为一个token,即将两个变量名合成一个变量名.&#xA;例子:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define LINK(A,B) A##B&#xA;int ab =9;&#xA;printf(&amp;#34;%d&amp;#34;,LINK(a,b));&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果就是9&lt;/p&gt;</description>
    </item>
    <item>
      <title>汇编中的寄存器</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description>&lt;h3 id=&#34;汇编中各式各样的寄存器&#34;&gt;汇编中各式各样的寄存器&lt;/h3&gt;&#xA;&lt;p&gt;通用寄存器:eax,ebx,ecx,edx&#xA;源变址和目标变址寄存器:ESI,EDI&#xA;栈相关寄存器:SS,ESP,EBP&#xA;代码段相关寄存器:CS,EIP&#xA;数据段相关寄存器:DS(常与ESI寄存器结合使用)&#xA;附加段寄存器:ES(常与EDI寄存器结合使用)&#xA;控制寄存器:CR0-CR3&#xA;系统地址寄存器:GDTR,LDTR,IDTR,TR&lt;/p&gt;&#xA;&lt;p&gt;Flag寄存器标志位含义:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ZF零标志,用来反映运算结果是否为零,如果为零则该标志位置为1&lt;/li&gt;&#xA;&lt;li&gt;AF辅助进位标志,运算过程中第三位有进位,则置为1&lt;/li&gt;&#xA;&lt;li&gt;PF奇偶标志,当运算结果中有偶数个1时,置为1&lt;/li&gt;&#xA;&lt;li&gt;SF符号标志,当运算结果为负数时,置为1&lt;/li&gt;&#xA;&lt;li&gt;CF进位标志,最高有效位产生进位时,置为1&lt;/li&gt;&#xA;&lt;li&gt;OF溢出标志,若操作数结果超出了机器能够表示的范围,则产生溢出,置为1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;cisc汇编和risc汇编&#34;&gt;CISC汇编和RISC汇编&lt;/h3&gt;&#xA;&lt;p&gt;CISC与RISC主要区别&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;比较内容&lt;/th&gt;&#xA;          &lt;th&gt;CISC&lt;/th&gt;&#xA;          &lt;th&gt;RISC&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令系统&lt;/td&gt;&#xA;          &lt;td&gt;复杂,庞大&lt;/td&gt;&#xA;          &lt;td&gt;精简&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令数目&lt;/td&gt;&#xA;          &lt;td&gt;一般大于200&lt;/td&gt;&#xA;          &lt;td&gt;一般小于100&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令长度&lt;/td&gt;&#xA;          &lt;td&gt;不固定&lt;/td&gt;&#xA;          &lt;td&gt;等长&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;可访存指令&lt;/td&gt;&#xA;          &lt;td&gt;不加限制&lt;/td&gt;&#xA;          &lt;td&gt;只有load和store&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令使用频率&lt;/td&gt;&#xA;          &lt;td&gt;相差很大&lt;/td&gt;&#xA;          &lt;td&gt;相差不大&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令执行时间&lt;/td&gt;&#xA;          &lt;td&gt;相差很大&lt;/td&gt;&#xA;          &lt;td&gt;大多在一个周期完成&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;优化编译实现&lt;/td&gt;&#xA;          &lt;td&gt;很难&lt;/td&gt;&#xA;          &lt;td&gt;较为容易&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;程序源代码长度&lt;/td&gt;&#xA;          &lt;td&gt;较短&lt;/td&gt;&#xA;          &lt;td&gt;较长&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;控制器实现方式&lt;/td&gt;&#xA;          &lt;td&gt;绝大多数为微程序控制&lt;/td&gt;&#xA;          &lt;td&gt;绝大多数为硬布线控制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;系统软件开发时间&lt;/td&gt;&#xA;          &lt;td&gt;较短&lt;/td&gt;&#xA;          &lt;td&gt;较长&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;CISC指令集复杂丰富,功耗大,每条指令长度也不固定(1-6个字节),不适用于移动端,因此移动端几乎被RISC占据&lt;/li&gt;&#xA;&lt;li&gt;在RISC中,CPU并不会对内存中的数据进行操作,所有的计算都要求在寄存器中完成,而寄存器和内存的通信则由单独指令完成,CISC中CPU可以直接对内存操作&lt;/li&gt;&#xA;&lt;li&gt;RISC拥有更多的通用寄存器,每个寄存器都可以用作数据存储和寻址&lt;/li&gt;&#xA;&lt;li&gt;RISC指令集能够非常有效地采用流水线,超流水线和超标量技术,实现指令级的并行操作,从而提高效率&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;x86指令讲解&#34;&gt;x86指令讲解&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;mov指令&#xA;格式:mov reg/mem, reg/mem/imme&#xA;注意:段寄存器不能直接用mov指令传送,以下指令是错误的&#xA;mov ds, es&#xA;mov ds, 5&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;常见汇编指令与机器码&#34;&gt;常见汇编指令与机器码&lt;/h3&gt;&#xA;&lt;p&gt;short jump -&amp;gt; eb (8位)&#xA;near jump -&amp;gt; e9 (16位)&#xA;far jump -&amp;gt; ea (32位)&#xA;je/jz -&amp;gt; 74&#xA;jne/jnz -&amp;gt; 75&#xA;nop -&amp;gt; 90&#xA;int 3 -&amp;gt; cc&#xA;ret -&amp;gt; c3&#xA;call eax -&amp;gt; d0ff&#xA;jmp esp -&amp;gt; e4ff&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows系统下各种链接</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sun, 29 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E9%93%BE%E6%8E%A5/</guid>
      <description>&lt;h3 id=&#34;0x00-硬链接&#34;&gt;0x00 硬链接&lt;/h3&gt;&#xA;&lt;p&gt;和GNU/Linux相同的是，Windows也有自己的链接创建工具mklink。Windows下的硬链接只允许在NTFS格式的文件系统下创建（通过CreateHardLink()系统调用），并且和Linux一样，硬链接的创建只能针对文件，而不能针对目录。&lt;/p&gt;&#xA;&lt;p&gt;创建硬链接的命令时mklink /H &amp;lt; destination &amp;gt; &amp;lt; source &amp;gt;，在创建后的图标也和原文件的图标一样，在属性中也无法看出其中的链接关系。唯一的方法就是通过fsutil hardlink list &amp;lt; filepath &amp;gt;来查看一个文件包含了多少硬链接。创建硬链接后，文件属性显示空间占用是与原文件大小相同的，但是实际上它并没有占用空间，真实的空间占用为0，硬链接不会把文件再复制一份。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x01-符号链接&#34;&gt;0x01 符号链接&lt;/h3&gt;&#xA;&lt;p&gt;创建符号（软）链接的命令为mklink &amp;lt; destination &amp;gt; &amp;lt; source &amp;gt;，也就是不为mklink提供其他的参数。建立之后，我们会发现软链接图标带有一个快捷方式样式的箭头，但是其文件属性的类型仍为原来的文件类型，Size却为0，并且有很多项都是灰色disable状态。&#xA;但是需要说明的是，通过这种方式建立软链接只能针对文件建立。如果需要给文件夹建立软链接，那么就需要通过加入/D参数来建立，详情见mklink命令说明。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x02-junction链接&#34;&gt;0x02 junction链接&lt;/h3&gt;&#xA;&lt;p&gt;Junction是Windows NTFS特有的一种链接方式。Junction和软链接类似，也是通过记录文件路径来访问文件。但是首先，Junction只针对文件夹，我们不能为文件建立Junction；其次，当我们删除Junction链接后，原文件夹也会被删除。Junction最常用的地方是用户目录下，我们会看到一些带有快捷方式图标的隐藏文件夹，但是当我们试图去访问的时候，则会被拒绝（即使是管理员也不行）。&lt;/p&gt;&#xA;&lt;p&gt;我们可以通过mklink /J &amp;lt; destination &amp;gt; &amp;lt; source &amp;gt;命令来建立Junction。在直观看来，Junction似乎也是介于软硬链接之间的一种奇葩存在，比如Junction的图标是带有箭头的，但是在文件夹的属性中，却看不到类似于软链接的那种shortcut选项卡，更像是硬链接的感觉。&lt;/p&gt;&#xA;&lt;p&gt;实际上，Windows之所以要在用户目录下面建立诸多的Junction的目的就在于和老版本的软件兼容。我们知道在xp时代，程序数据通常储存在Application Data文件夹中，但是当Windows转向Vista时，目录名和位置都有所变化，变成了AppData，这样，对于以前的硬编码安装路径的程序，就会遇到安装错误的问题。于是MS决定通过Junction的方式来解决。这样当某个程序访问或写入Application Data时，其所访问的是AppData文件夹，这样就避免了版本不兼容的问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x03-快捷方式&#34;&gt;0x03 快捷方式&lt;/h3&gt;&#xA;&lt;p&gt;其实我们最熟悉也是最常用的快捷方式并不属于传统概念上的“链接”。虽然似乎快捷方式有点类似于软链接，但是它们的本质还是非常不同的。链接其实更贴近操作系统和文件系统的概念。而快捷方式，其实是一个真真实实的以lnk作为文件类型的文件。只不过操作系统（更确切的说是Windows的shell，explorer）可以对这种lnk文件解释而已。而快捷方式的功能其实也要比传统的Linux或WIndows的软链接的功能更强大一些。如果我们打开一个快捷方式的属性，我们就会发现原来在软链接的属性中不可修改的部分都变成了可以修改的，这里面包含了文件的打开方式，快捷键，以何种窗口模式打开等属性。&lt;/p&gt;&#xA;&lt;p&gt;也就是说，快捷方式不同于软链接的地方，就是它不仅仅是个包含文件路径的文件，而是增加了许多其他信息。这种和窗口化相关的信息如果基于文件系统自然是非常不便的，所以MS就单独设计了lnk文件，由explorer来执行。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x04-总结与区别&#34;&gt;0x04 总结与区别&lt;/h3&gt;&#xA;&lt;p&gt;所谓硬链接，我们可以理解为硬链接持有的是文件本身（而不是路径）的引用。也就是说，当我们给一个名为a.txt的文件建立硬链接（b.txt）后，那么b.txt指向的位置就是a.txt这个文件本身，而此时，a.txt和b.txt是同级平行的，这个文本文件此时同时拥有两个文件名。当我们删除a.txt时，只是删除了a.txt这个文件名，这个文件仍然被b.txt所引用，所以我们还能够通过b.txt访问。而软链接，持有的则是原链接路径。比如a.txt位于 ../Document/a.txt ，那么为其建立软链接b.txt的内容就是 ../Document/a.txt，此时，我们访问b.txt，其实是在按照a.txt的路径去访问a.txt。如果我们这时删除a.txt这个文件，那么b.txt也会无效，因为文件已经不存在了。&lt;/p&gt;&#xA;&lt;p&gt;而junction链接则是介于软链接和硬链接之间的一种为了解决向下兼容问题的独特链接，快捷方式则是对软链接的一种补充，ink格式的文件提供了我们对打开方式修改的能力。&lt;/p&gt;&#xA;&lt;h3 id=&#34;关于winsxs的补充&#34;&gt;关于WinSxS的补充&lt;/h3&gt;&#xA;&lt;p&gt;WinSxS位于%systemroot%\WinSxS，其中存放的是Windows系统文件以及DLL文件的若干个副本。由于应用程序可以使用同一个DLL文件，因此出于兼容性与还原至旧版本的考虑，系统会在这里存放多个不同版本的文件副本。&lt;/p&gt;&#xA;&lt;p&gt;使用一些硬链接查看的工具可以发现，Windows当中的大部分系统文件都是该目录下文件的硬链接。因此该目录是系统正常运行不可或缺的。&#xA;为一个文件创造硬链接后使用fsutil工具查看会显示出原文件和目标文件的路径。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;hardlink1.png&#34; alt=&#34;&#34;&gt;&lt;img src=&#34;hardlink2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SecureBoot机制</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/secureboot%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/secureboot%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h3 id=&#34;从用户态恶意软件说起&#34;&gt;从用户态恶意软件说起&lt;/h3&gt;&#xA;&lt;p&gt;随着攻防技术在对抗中彼此不断进步,微软在对用户态恶意软件的防护已经很成熟了,对于微软商店中的软件(虽然微软商店的软件不是主流,涵盖的软件也相对较少,但这是一种趋势),本身就是运行在沙盒环境中,很难掀起什么风浪,而对于传统的桌面端软件,有Windows defender的签名检测,smartscreen对于不信任软件的提醒,以及uac对软件提权请求的拦截。&lt;/p&gt;&#xA;&lt;p&gt;对于内核态恶意软件呢?用户态的恶意软件能做的事情其实很有限,只有到达内核态,与操作系统拥有相同的权限,才能做更多的事情,微软对这些rootkits有哪些防御措施&lt;/p&gt;&#xA;&lt;h3 id=&#34;rootkit的简明分类&#34;&gt;rootkit的简明分类&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Firmware rootkit:这种恶意软件通过patch BIOS以及其他固件,达到在Windows之前启动的目的,从而达到隐藏和进行恶意操作的目的&lt;/li&gt;&#xA;&lt;li&gt;Bootkit:对bootloader动手脚,bootloader是引导Windows系统的一个关键程序,以达到在Windows之前启动的目的&lt;/li&gt;&#xA;&lt;li&gt;Kernel rootkit:替换部分Windows的系统关键驱动,以便达到和Windows一起启动的效果&lt;/li&gt;&#xA;&lt;li&gt;Driver rootkit:伪装成受Windows信任的第三方驱动程序,进行恶意活动&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;对应措施&#34;&gt;对应措施&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Secure Boot:带有UEFI固件和可信平台模块(TPM)的PC可以配置为只加载可信操作系统引导加载程序&lt;/li&gt;&#xA;&lt;li&gt;Trusted Boot:Windows会在加载启动之前检查每个组件的完整性。&lt;/li&gt;&#xA;&lt;li&gt;Early Launch Anti-Malware (ELAM):在加载之前,杀毒驱动会先加载测试所有驱动程序,并防止未经批准的驱动程序加载。&lt;/li&gt;&#xA;&lt;li&gt;Measured Boot:PC的固件记录引导过程可以被发送到可信的服务器,从而客观地评估PC的健康状况&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;一些细节&#34;&gt;一些细节&lt;/h3&gt;&#xA;&lt;p&gt;当装有UEFI的PC启动时,PC首先验证固件是数字签名的,从而降低firmware rootkit的风险。如果启用了secure boot,固件将检查bootloader的数字签名,以保证它没有被修改,并在随后检查其是否有受信任证书,如果这些成功,secure boot的工作就完成了,对于secure boot来说,它可以使用TPM但不要求必须有TPM,而Measured Boot则需要TPM支持&lt;/p&gt;&#xA;&lt;p&gt;之后,bootloader在加载内核之前会对其进行数字签名验证, 随后内核依次验证Windows启动过程中的所有其他组件,包括启动驱动程序,启动文件和ELAM等,如果文件已被修改则拒绝加载损坏的组件,Windows 10通常可以自动修复损坏的组件,恢复Windows的完整性并允许PC正常启动&lt;/p&gt;&#xA;&lt;p&gt;ELAM说白了就是在加载一些第三方驱动之前最先加载杀毒软件的驱动,这样一来恶意软件即使伪装成驱动,权限也不会有杀毒软件的高,杀毒软件可以轻松干掉它,从而继续这条信任链。 由于操作系统尚未启动，并且Windows需要尽快启动，因此ELAM的任务很简单：检查每个要加载的驱动并确定其是否在受信任的驱动程序列表中,如果不受信任,就不会加载它。&lt;/p&gt;&#xA;&lt;p&gt;至于Measured Boot,没有TPM的情况下不会生效&lt;/p&gt;</description>
    </item>
    <item>
      <title>msvcrt的链接</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/msvcrt%E7%9A%84%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/msvcrt%E7%9A%84%E9%93%BE%E6%8E%A5/</guid>
      <description>&lt;h3 id=&#34;运行时库&#34;&gt;运行时库&lt;/h3&gt;&#xA;&lt;p&gt;运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件，从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如malloc,free, printf等等），如果我们的程序需要使用这些功能（事实上，只要是C/C++程序就一定会用到运行时库提供的功能），就要链接C/C++运行时库。上次弄了半天也没找到链接msvcrt的方法,今天在又一次学习静态库和静态库的时候发现了.&lt;/p&gt;&#xA;&lt;p&gt;这是c语言链接的方式,VS已经在背地里偷偷帮你做了,你只需要#include&amp;lt;头文件&amp;gt;就可以调用函数了,通过命令行命令VS自动帮你#pragma comment()了.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;C语言标准库&lt;/th&gt;&#xA;          &lt;th&gt;特征&lt;/th&gt;&#xA;          &lt;th&gt;选项&lt;/th&gt;&#xA;          &lt;th&gt;预处理器指令&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcmt.lib&lt;/td&gt;&#xA;          &lt;td&gt;将本机 CRT 启动静态链接到你的代码。&lt;/td&gt;&#xA;          &lt;td&gt;/MT&lt;/td&gt;&#xA;          &lt;td&gt;_MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcmtd.lib&lt;/td&gt;&#xA;          &lt;td&gt;静态链接本机 CRT 启动的调试版本。 不可再发行。&lt;/td&gt;&#xA;          &lt;td&gt;/MTd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcrt.lib 和 msvcrxxx.dll&lt;/td&gt;&#xA;          &lt;td&gt;与 DLL UCRT 和 vcruntime 一起使用的本机 CRT 启动的静态库。&lt;/td&gt;&#xA;          &lt;td&gt;/MD&lt;/td&gt;&#xA;          &lt;td&gt;_MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcrtd.lib 和 msvcrxxxd.dll&lt;/td&gt;&#xA;          &lt;td&gt;与 DLL UCRT 和 vcruntime 一起使用的本机 CRT 启动调试版本的静态库, 不可再发行。&lt;/td&gt;&#xA;          &lt;td&gt;/MDd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;下面是C++运行时的标准库链接方法&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;C++ 标准库&lt;/th&gt;&#xA;          &lt;th&gt;特征&lt;/th&gt;&#xA;          &lt;th&gt;选项&lt;/th&gt;&#xA;          &lt;th&gt;预处理器指令&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcpmt.lib&lt;/td&gt;&#xA;          &lt;td&gt;多线程, 静态链接&lt;/td&gt;&#xA;          &lt;td&gt;/MT&lt;/td&gt;&#xA;          &lt;td&gt;_MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcprt.lib 和 msvcpxxx.dll&lt;/td&gt;&#xA;          &lt;td&gt;多线程动态链接（MSVCPversion.dll 的导入库）&lt;/td&gt;&#xA;          &lt;td&gt;/MD&lt;/td&gt;&#xA;          &lt;td&gt;_MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcpmtd.lib&lt;/td&gt;&#xA;          &lt;td&gt;多线程, 静态链接&lt;/td&gt;&#xA;          &lt;td&gt;/MTd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcprtd.lib 和 msvcpxxxd.dll&lt;/td&gt;&#xA;          &lt;td&gt;多线程动态链接（MSVCPversionD.DLL 的导入库）&lt;/td&gt;&#xA;          &lt;td&gt;/MDd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;xxx代表版本,cp的意思就是c++,d就是debug版本的意思,最后没有d就是release版了.&#xA;同样也是VS偷偷帮我们做的.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ntdll提权函数使用</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/ntdll%E5%86%85%E7%9A%84%E6%8F%90%E6%9D%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/ntdll%E5%86%85%E7%9A%84%E6%8F%90%E6%9D%83%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h3 id=&#34;rtladjustprivilege函数略解&#34;&gt;RtlAdjustPrivilege函数略解&lt;/h3&gt;&#xA;&lt;p&gt;NTSTATUS RtlAdjustPrivilege&#xA;(&#xA;ULONG Privilege,&#xA;BOOLEAN Enable,&#xA;BOOLEAN CurrentThread,&#xA;PBOOLEAN Enabled&#xA;)&lt;/p&gt;&#xA;&lt;p&gt;参数的含义：&#xA;Privilege [In] Privilege index to change.&#xA;// 所需要的权限名称，可以到 MSDN 查找关于 Process Token &amp;amp; Privilege 内容可以查到&lt;/p&gt;&#xA;&lt;p&gt;Enable [In] If TRUE, then enable the privilege otherwise disable.&#xA;// 如果为True 就是打开相应权限，如果为False 则是关闭相应权限&lt;/p&gt;&#xA;&lt;p&gt;CurrentThread [In] If TRUE, then enable in calling thread, otherwise process.&#xA;// 如果为True 则仅提升当前线程权限，否则提升整个进程的权限&lt;/p&gt;&#xA;&lt;p&gt;Enabled [Out] Whether privilege was previously enabled or disabled.&#xA;// 输出该权限之前的状态是开启还是关闭&lt;/p&gt;&#xA;&lt;p&gt;权限ID对应的字码以及描述&#xA;1.SeCreateTokenPrivilege 0x2 Create a token object&#xA;2.SeAssignPrimaryTokenPrivilege 0x3 Replace a process level token&#xA;3.SeLockMemoryPrivilege 0x4 Lock pages in memory&#xA;4.SeIncreaseQuotaPrivilege 0x5 Adjust memory quotas for a process&#xA;5.SeUnsolicitedInputPrivilege 0x0&#xA;6.SeMachineAccountPrivilege 0x6&#xA;7.SeTcbPrivilege 0x7 Act as part of the operating system&#xA;8.SeSecurityPrivilege 0x8 Manage auditing and security log&#xA;9.SeTakeOwnershipPrivilege 0x9 Take ownership of files or other objects&#xA;10.SeLoadDriverPrivilege 0xa Load and unload device drivers&#xA;11.SeSystemProfilePrivilege 0xb Profile system performance&#xA;12.SeSystemtimePrivilege 0xc Change the system time&#xA;13.SeProfileSingleProcessPrivilege 0xd Profile single process&#xA;14.SeIncreaseBasePriorityPrivilege 0xe Increase scheduling priority&#xA;15.SeCreatePagefilePrivilege 0xf Create a pagefile&#xA;16.SeCreatePermanentPrivilege 0x10 Create permanent shared objects&#xA;17.SeBackupPrivilege 0x11&#xA;18.SeRestorePrivilege 0x12&#xA;19.SeShutdownPrivilege 0x13&#xA;20.SeDebugPrivilege 0x14&#xA;21.SeAuditPrivilege 0x15 Generate security audits&#xA;22.SeSystemEnvironmentPrivilege 0x16 Modify firmware environment values&#xA;23.SeChangeNotifyPrivilege 0x17 Bypass traverse checking&#xA;24.SeRemoteShutdownPrivilege 0x18&#xA;25.SeUndockPrivilege 0x19 Remove computer from docking station   &lt;br&gt;&#xA;26.SeSyncAgentPrivilege 0x1a&#xA;27.SeEnableDelegationPrivilege 0x1b&#xA;28.SeManageVolumePrivilege 0x1c Perform volume maintenance tasks&#xA;29.SeImpersonatePrivilege 0x1d Impersonate a client after authentication&#xA;30.SeCreateGlobalPrivilege 0x1e&#xA;31.SeTrustedCredManAccessPrivilege 0x1f Access Credential Manager as a trusted caller&#xA;32.SeRelabelPrivilege 0x20 Modify an object label&#xA;33.SeIncreaseWorkingSetPrivilege 0x21 Increase a process working set&#xA;34.SeTimeZonePrivilege 0x22&#xA;35.SeCreateSymbolicLinkPrivilege 0x23&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86和x64汇编传参问题</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/confusing-x86-64/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/confusing-x86-64/</guid>
      <description>&lt;h3 id=&#34;先看看x86的传参&#34;&gt;先看看x86的传参&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;push eax&#xA;call xxx&#xA;&#xA;xxx fun proc&#xA;&#xA;push        ebp          保存栈底&#xA;mov         ebp,esp      设置ebp&#xA;sub         esp,0C0h     开辟局部变量空间&#xA;push        ebx          保存寄存器环境&#xA;push        esi  &#xA;push        edi  &#xA;&#xA;pop         edi          恢复寄存器环境&#xA;pop         esi  &#xA;pop         ebx          &#xA;mov         esp,ebp      释放局部变量空间&#xA;pop         ebp          恢复栈底&#xA;ret                      返回,平栈,如果是c的调用方式 则add esp,xxx在外部平栈, stdcall 则内部平栈 ret 4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结一下就是:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;往栈中存放参数&lt;/li&gt;&#xA;&lt;li&gt;将返回地址入栈&lt;/li&gt;&#xA;&lt;li&gt;保存栈底&lt;/li&gt;&#xA;&lt;li&gt;栈内部进行自己的 申请空间 保存环境 以及释放.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;再看看x64下的参数传递&#34;&gt;再看看x64下的参数传递&lt;/h3&gt;&#xA;&lt;p&gt;调用者部分:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sub rsp,0x28&#xA;mov r9,1&#xA;mov r8,2&#xA;mov rdx,3&#xA;mov rcx,4&#xA;call xxx&#xA;add rsp,0x28&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;被调函数:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;xxx                 &#xA;&#xA;mov qword ptr [rsp + 0x20],r9&#xA;mov qword ptr [rsp + 0x18],r8&#xA;mov qword ptr [rsp + 0x10],rdx&#xA;mov qword ptr [rsp + 8],rcx&#xA;push rbp&#xA;&#xA;xxx &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:&lt;/p&gt;</description>
    </item>
    <item>
      <title>dll注入与hook</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/dll%E6%B3%A8%E5%85%A5%E5%92%8Chook/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/dll%E6%B3%A8%E5%85%A5%E5%92%8Chook/</guid>
      <description>&lt;h3 id=&#34;使用dll的方法&#34;&gt;使用dll的方法&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;隐式链接(lib+dll+头文件)&#xA;#pragma comment(lib,&amp;ldquo;libname.lib&amp;rdquo;)&#xA;#include&amp;lt;libname.h&amp;gt;&#xA;调用&lt;/li&gt;&#xA;&lt;li&gt;只有dll文件(显式链接)&#xA;LoadLibrary hModule&#xA;GetProcAddress funcName&#xA;FreeLibrary&#xA;或在.h文件中: extern &amp;ldquo;C&amp;rdquo; funcName()&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在动态链接库项目被编译后,会生成lib文件和dll文件&#xA;.lib文件: 存储了导出函数的名称和位置&#xA;.dll文件: 包含实际的函数代码和数据&lt;/p&gt;&#xA;&lt;h3 id=&#34;dll劫持&#34;&gt;dll劫持&lt;/h3&gt;&#xA;&lt;p&gt;原理:程序调用loadlibrary载入库时,如果使用了相对路径,可能会加载同名其他恶意dll&#xA;dll加载目录搜索顺序:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序所在目录&lt;/li&gt;&#xA;&lt;li&gt;加载dll时所在的当前目录(比如在桌面打开图片,桌面就是当前目录)&lt;/li&gt;&#xA;&lt;li&gt;系统目录system32&lt;/li&gt;&#xA;&lt;li&gt;Windows目录&lt;/li&gt;&#xA;&lt;li&gt;Path环境变量下的目录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;微软的应对措施:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开启safedllsearchmode,改变加载顺序,即将上表中的第二加载改为倒数第二加载&lt;/li&gt;&#xA;&lt;li&gt;注册表中knowndlls项规定了某些特殊的dll,这些dll必须在system32目录中寻找并加载&lt;/li&gt;&#xA;&lt;li&gt;微软还提供了一个ExcludeFromKnownDlls项,重启生效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;防御:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用绝对路径&lt;/li&gt;&#xA;&lt;li&gt;白名单,签名机制&lt;/li&gt;&#xA;&lt;li&gt;SetDllDirectory把当前目录一项去掉&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;全局钩子&#34;&gt;全局钩子&lt;/h3&gt;&#xA;&lt;p&gt;HHOOK WINAPI SetWindowsHookEx(&#xA;int idhook;\钩子类型&#xA;HOOKPROC lpfn;\回调函数地址&#xA;HINSTANCE hMod;\包含lpfn的实例句柄&#xA;DWORD dwThreadid;\线程ID,如果是零,则监控所有线程的全局钩子&#xA;)&#xA;钩子类型:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;值&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_CALLWNDPROC&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_CALLWNDPROCRET&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，在目标窗口过程处理消息后监视消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_CBT&lt;/td&gt;&#xA;          &lt;td&gt;安装接收对CBT应用程序有用的通知的挂钩程序。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_DEBUG&lt;/td&gt;&#xA;          &lt;td&gt;安装可用于调试其他挂钩程序的挂钩程序。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_FOREGROUNDIDLE&lt;/td&gt;&#xA;          &lt;td&gt;安装将在应用程序的前台线程即将变为空闲时调用的钩子过程。该挂钩对于在空闲时执行低优先级任务很有用。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_GETMESSAGE&lt;/td&gt;&#xA;          &lt;td&gt;安装一个监视发送到消息队列的消息的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_JOURNALPLAYBACK&lt;/td&gt;&#xA;          &lt;td&gt;安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_JOURNALRECORD&lt;/td&gt;&#xA;          &lt;td&gt;安装一个挂钩过程，记录发布到系统消息队列的输入消息。这个钩子对于录制宏很有用。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_KEYBOARD&lt;/td&gt;&#xA;          &lt;td&gt;安装监视按键消息的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_KEYBOARD_LL&lt;/td&gt;&#xA;          &lt;td&gt;安装监视低级别键盘输入事件的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_MOUSE&lt;/td&gt;&#xA;          &lt;td&gt;安装监视鼠标消息的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_MOUSE_LL&lt;/td&gt;&#xA;          &lt;td&gt;安装监视低级别鼠标输入事件的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_MSGFILTER&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，用于监视在对话框，消息框，菜单或滚动条中由于输入事件而生成的消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_SHELL&lt;/td&gt;&#xA;          &lt;td&gt;安装接收对shell应用程序有用的通知的挂钩程序。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_SYSMSGFILTER&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，用于监视在对话框，消息框，菜单或滚动条中由于输入事件而生成的消息。钩子程序监视与调用线程相同的桌面中的所有应用程序的这些消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;普通的钩子需要写在dll程序中才能执行,但是低级键盘钩子可以在无dll的情况下运行,比如低级键盘钩子和低级鼠标钩子,判断钩子的优先级遵循一个原则,后下的钩子先执行,WH_DEBUG&amp;gt;WH_KEYBOARD_LL&amp;gt;WH_KEYBOARD,即调试钩子&amp;gt;低级钩子&amp;gt;普通钩子&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows进程创建过程</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/</guid>
      <description>&lt;h3 id=&#34;子系统类型选项&#34;&gt;子系统类型选项&lt;/h3&gt;&#xA;&lt;p&gt;当创建一个饮用程序的时候,连接器选项中有一个很重要的参数,就是子系统类型选择(/SUBSYSTEM:),其中比较常用的有CONSOLE,WINDOWS,NATIVE三个选项,对应CUI程序,GUI程序以及系统和驱动程序这三种.&#xA;当用户运行应用程序时,系统的PE loader会根据可选PE头中的信息来加载程序,如果是CUI程序,系统会保证至少有一个终端来显示程序运行的结果(举例来说就是如果从cmd中打开CUI程序,若不是命令指定在新窗口中打开,则只会在输入命令的终端窗口显示输出结果;而如果我们用任务管理器开启一个CUI程序,则系统会帮我们打开一个新终端来显示结果,至于为什么结果会一闪而过,这是因为你在编写程序时没加一些让它停下来的指令,程序运行完成就return 0么得了)&#xA;而如果这是一个GUI程序,系统就只会加载这个程序,不会给你加一个默认的界面,因为他认为你自己会设计一个图形化的界面的.&lt;/p&gt;&#xA;&lt;h3 id=&#34;main函数开始之前是什么&#34;&gt;main函数开始之前是什么&lt;/h3&gt;&#xA;&lt;p&gt;main函数是我们程序员写下的代码开始发挥作用的地方,但是程序运行时最先执行的函数并不是main函数,main函数之前操作系统会调用c/c++运行时启动函数比图mainCRTStartup这种东西,GUI程序则是WinMainCRTStartup函数.这个函数主要做哪些事情:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;获取完整命令行和环境变量&lt;/li&gt;&#xA;&lt;li&gt;初始化c/c++运行库的全局变量&lt;/li&gt;&#xA;&lt;li&gt;初始化内存分配函数,比如malloc和alloc函数以及其他底层IO例程需要用到的堆,始化以下指针变量：stdin,stdout,stderr.(限控制台程序)&lt;/li&gt;&#xA;&lt;li&gt;调用所有全局变量和静态c++类对象的构造函数&#xA;完成这些工作后会调用应用程序的入口点函数,同时定义变量nMainRetVal = main函数的返回值,之后程序的控制权便交给了main函数(或者WinMain函数),当main函数返回后(即return 0),会调用exit函数,进行以下过程:&lt;/li&gt;&#xA;&lt;li&gt;调用_onexit函数调用所注册的函数&lt;/li&gt;&#xA;&lt;li&gt;调用所有全局变量和静态c++类对象的析构函数&lt;/li&gt;&#xA;&lt;li&gt;释放堆及其他资源&lt;/li&gt;&#xA;&lt;li&gt;调用exit函数退出程序,向其传入的参数是main函数的返回值&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;不被注意但是天天见的explorer&#34;&gt;不被注意但是天天见的explorer&lt;/h3&gt;&#xA;&lt;p&gt;explorer进程掌管着进入系统后我们在桌面上看到的大部分东西:壁纸,快捷方式,桌面上基本一切的一切都是它产生的,如果你kill掉这个process,桌面就乌漆嘛黑啥也没了.我们双击图标能够创建进程,就是归功于explorer.exe的,这个程序会在你双击图标的时候调用CreateProcess函数创建进程.&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程是如何创建出来的&#34;&gt;进程是如何创建出来的&lt;/h3&gt;&#xA;&lt;p&gt;首先明确一点就是任何进程都是其他进程创建出来的,比如一般我们在桌面上双击图标就是让explorer创建了进程.&#xA;进程的创建过程:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;映射exe文件(简单说是把文件放到内存中,)&lt;/li&gt;&#xA;&lt;li&gt;创建内核对象EPROCESS&lt;/li&gt;&#xA;&lt;li&gt;映射系统DLL(ntdll.dll)&lt;/li&gt;&#xA;&lt;li&gt;创建线程内核对象ETHREAD&lt;/li&gt;&#xA;&lt;li&gt;系统创建线程&lt;/li&gt;&#xA;&lt;li&gt;映射dll(ntdll!LdrlnitializeThunk)&lt;/li&gt;&#xA;&lt;li&gt;线程开始执行&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;关键系统进程&#34;&gt;关键系统进程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;System Idle Process进程:pid为0,处理器有几个线程这玩意有几个线程,功能是循环统计CPU的空闲度,这个值越大越好。&lt;/li&gt;&#xA;&lt;li&gt;System进程：ID为4，包含了内核模式系统线程。系统辅助线程、执行体和驱动进程通过PsCreateSystemThread创建的线程都在System中。这个进程中的所有模块都处在高地址的内核内存区(即0x80000000后),受到保护.&lt;/li&gt;&#xA;&lt;li&gt;winlogon.exe：登录进程，负责用户交互的登录和注销。Ctrl+Alt+Del就是给它发请求。这就是为什么手贱结束explorer进程之后仍然可以Ctrl+Alt+Del打开任务管理器再次启动explorer进程来恢复正常.&lt;/li&gt;&#xA;&lt;li&gt;csrss.exe：Windows子系统环境进程，包括控制面板窗口的功能，创建删除进程和线程。&lt;/li&gt;&#xA;&lt;li&gt;lsass.exe：本地系统安全策略。负责允许哪些用户登录到本地系统、口令策略、授予用户和用户组的特权、系统安全审计设置、认证用户身份、安全审计消息发送到系统的Event Log等功能。&lt;/li&gt;&#xA;&lt;li&gt;services.exe：负责管理Windows系统服务，这里的系统服务指一些特殊的进程，通常不与登录用户进行交互，因而被配置成可以在系统引导时自启动，无需交互登录过程。Windows中很多功能组件都是以服务方式实现的，比如Event Log，任务调度器和各种网络组件等。&lt;/li&gt;&#xA;&lt;li&gt;smss.exe:这是Windows的核心进程之一，是Windows NT内核的会话管理程序。&lt;/li&gt;&#xA;&lt;li&gt;Svchost.exe:这属于Windows的系统程序，服务进程的执行离不开这个程序。开机出现“Generic host processfor win32 services”（遇到问题需要关闭），一般是这个进程找不到dll文件所致。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>windows 10下利用schtasks绕过uac</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/uac_bypass/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/uac_bypass/</guid>
      <description>&lt;h3 id=&#34;0x00-前言&#34;&gt;0x00 前言&lt;/h3&gt;&#xA;&lt;p&gt;最近在刷知乎的时候发现了一种早就被揭露但目前为止还未被修复的uac bypass手段，个人觉得其中的思路很有参考意义，故记录下来学习一下。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x01-原理&#34;&gt;0x01 原理&lt;/h3&gt;&#xA;&lt;p&gt;这种uac bypass的原理是寻找权限控制不严格的程序进行劫持，以达到绕过uac使用管理员权限的shell。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x02-利用方法&#34;&gt;0x02 利用方法&lt;/h3&gt;&#xA;&lt;p&gt;计划任务中的silentcleanup的关键信息如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-16&amp;#34;?&amp;gt;&#xA;&amp;lt;Task xmlns=&amp;#34;http://schemas.microsoft.com/windows/2004/02/mit/task&amp;#34;&amp;gt;&#xA;  &amp;lt;RegistrationInfo&amp;gt;&#xA;    &amp;lt;SecurityDescriptor&amp;gt;D:AI(A;;FA;;;BA)(A;;FA;;;SY)(A;;FRFX;;;AU)&amp;lt;/SecurityDescriptor&amp;gt;&#xA;    &amp;lt;Source&amp;gt;$(@%systemroot%\system32\cleanmgr.exe,-1300)&amp;lt;/Source&amp;gt;&#xA;    &amp;lt;Author&amp;gt;$(@%systemroot%\system32\cleanmgr.exe,-1300)&amp;lt;/Author&amp;gt;&#xA;    &amp;lt;Description&amp;gt;$(@%systemroot%\system32\cleanmgr.exe,-1301)&amp;lt;/Description&amp;gt;&#xA;    &amp;lt;URI&amp;gt;Microsoft\Windows\DiskCleanup\SilentCleanup&amp;lt;/URI&amp;gt;&#xA;  &amp;lt;/RegistrationInfo&amp;gt;&#xA;  &amp;lt;Principals&amp;gt;&#xA;    &amp;lt;Principal id=&amp;#34;Authenticated Users&amp;#34;&amp;gt;&#xA;      &amp;lt;GroupId&amp;gt;S-1-5-32-545&amp;lt;/GroupId&amp;gt;&#xA;      &amp;lt;RunLevel&amp;gt;HighestAvailable&amp;lt;/RunLevel&amp;gt;&#xA;    &amp;lt;/Principal&amp;gt;&#xA;  &amp;lt;/Principals&amp;gt;&#xA;  &amp;lt;Settings&amp;gt;&#xA;    &amp;lt;DisallowStartIfOnBatteries&amp;gt;true&amp;lt;/DisallowStartIfOnBatteries&amp;gt;&#xA;    &amp;lt;StopIfGoingOnBatteries&amp;gt;true&amp;lt;/StopIfGoingOnBatteries&amp;gt;&#xA;    &amp;lt;ExecutionTimeLimit&amp;gt;PT15M&amp;lt;/ExecutionTimeLimit&amp;gt;&#xA;    &amp;lt;MultipleInstancesPolicy&amp;gt;IgnoreNew&amp;lt;/MultipleInstancesPolicy&amp;gt;&#xA;    &amp;lt;StartWhenAvailable&amp;gt;true&amp;lt;/StartWhenAvailable&amp;gt;&#xA;    &amp;lt;RunOnlyIfIdle&amp;gt;true&amp;lt;/RunOnlyIfIdle&amp;gt;&#xA;    &amp;lt;IdleSettings&amp;gt;&#xA;      &amp;lt;StopOnIdleEnd&amp;gt;true&amp;lt;/StopOnIdleEnd&amp;gt;&#xA;      &amp;lt;RestartOnIdle&amp;gt;true&amp;lt;/RestartOnIdle&amp;gt;&#xA;    &amp;lt;/IdleSettings&amp;gt;&#xA;    &amp;lt;UseUnifiedSchedulingEngine&amp;gt;true&amp;lt;/UseUnifiedSchedulingEngine&amp;gt;&#xA;    &amp;lt;MaintenanceSettings&amp;gt;&#xA;      &amp;lt;Period&amp;gt;P1D&amp;lt;/Period&amp;gt;&#xA;      &amp;lt;Deadline&amp;gt;P1M&amp;lt;/Deadline&amp;gt;&#xA;    &amp;lt;/MaintenanceSettings&amp;gt;&#xA;  &amp;lt;/Settings&amp;gt;&#xA;  &amp;lt;Triggers /&amp;gt;&#xA;  &amp;lt;Actions Context=&amp;#34;Authenticated Users&amp;#34;&amp;gt;&#xA;    &amp;lt;Exec&amp;gt;&#xA;      &amp;lt;Command&amp;gt;%windir%\system32\cleanmgr.exe&amp;lt;/Command&amp;gt;&#xA;      &amp;lt;Arguments&amp;gt;/autoclean /d %systemdrive%&amp;lt;/Arguments&amp;gt;&#xA;    &amp;lt;/Exec&amp;gt;&#xA;  &amp;lt;/Actions&amp;gt;&#xA;&amp;lt;/Task&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到Authenticated Users表示普通用户权限即可启动而RunLevel为Highest表示以高权限启动。这就使得劫持该程序可以运行拥有管理员权限的shell进行操作。&#xA;打开SilentCleanup这一文件查看其中代码，可知它其实是运行了%windir%\system32\cleanmgr.exe /autoclean /d %systemdrive% 这一命令。我们只要将%windir%的环境变量进行修改即可实现对该程序的劫持。&#xA;比如说：将%windir%设置为C:\hack并在C:\hack\system32下将payload.exe保存为cleanmgr.exe那么在启动计划任务SilentCleanup时，就会以高权限运行代码.&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x03-具体代码实现&#34;&gt;0x03 具体代码实现&lt;/h3&gt;&#xA;&lt;p&gt;分为两种版本吧：&#xA;1.cmd版本&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows编程中的Unicode问题</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/windows%E5%AF%B9unicode%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/windows%E5%AF%B9unicode%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>&lt;h3 id=&#34;windows操作系统内核对unicode的支持&#34;&gt;Windows操作系统内核对Unicode的支持&lt;/h3&gt;&#xA;&lt;p&gt;Windows操作系统内核中的字符表示为UTF-16小尾序，可以正确处理、显示以4字节存储的字符。但是Windows API实际上仅能正确处理UCS-2字符，即仅以2字节存储的，码位小于U+FFFF的Unicode字符。其根源是Microsoft C++语言把wchar_t数据类型定义为16比特的unsigned short，这就与一个wchar_t型变量对应一个宽字符，可以存储一个Unicode字符的规定相矛盾。相反，Linux平台的GCC编译器规定一个wchar_t是4字节长度，可以存储一个UTF-32字符，宁可浪费了很大的存储空间。&lt;/p&gt;&#xA;&lt;h3 id=&#34;windows编程中l_t-text和_text的使用及其区别&#34;&gt;windows编程中L，_T() ，TEXT和_TEXT的使用及其区别&lt;/h3&gt;&#xA;&lt;p&gt;其实一句话概括的话,其实没有区别。字符串（literal string）前面的大写字母L，用来告诉编译器该字符串应该作为Unicode来编译。它用来将ASNI转换为Unicode。&#xA;tchar.h中定义如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  1. #define _T(x)       __T(x)  &#xA;  2. #define _TEXT(x)    __T(x)  &#xA;  3.   &#xA;  4. #ifdef  _UNICODE  &#xA;  5. #define __T(x)      L ## x     &#xA;  6. #else  &#xA;  7. #define __T(x)      x         &#xA;  8. #endif  &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;winnt.h中定义如下:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  1. #define TEXT(quote) __TEXT(quote)   &#xA;  2.   &#xA;  3. #ifdef  UNICODE                       &#xA;  4. #define __TEXT(quote) L##quote        &#xA;  5. #else   /* UNICODE */                 &#xA;  6. #define __TEXT(quote) quote           &#xA;  7. #endif /* UNICODE */  &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到tchar.h是运行时的头文件，_T、_TEXT 根据_UNICODE来确定宏&#xA;winnt.h是Win的头文件根据，TEXT 根据UNICODE 来确定宏&lt;/p&gt;&#xA;&lt;p&gt;如果需要同时使用这3个宏，则需同时定义 UNICODE 和 _UNICODE_&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python编码问题</title>
      <link>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/%E4%BB%8Emsvcrt%E5%88%B0python%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E6%9C%BA%E5%88%B6/%E4%BB%8Emsvcrt%E5%88%B0python%E7%BC%96%E7%A0%81/</guid>
      <description>&lt;h3 id=&#34;起因&#34;&gt;起因&lt;/h3&gt;&#xA;&lt;p&gt;估计正常人很难想到这两者之间的关系,又是折腾的一天,我对mingw-w64的编译器如何链接msvcrt.dll文件产生一些疑问,在看Windows网络编程的时候,开头要加上一句命令:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;#pragma comment(lib,&amp;ldquo;WS2_32&amp;rdquo;)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;通过这条命令来链接dll库,那么编译器是如何链接msvcrt.dll的,翻找了一些头文件,并未看到有相关的语句,一个个找又太麻烦,还是让脚本来帮我找一下吧,python撸一个脚本.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os&#xA;path = &amp;#34;D:\\mingw\\mingw64\\x86_64-w64-mingw32\\include&amp;#34; #文件夹目录&#xA;files= os.listdir(path) &#xA;s = []&#xA;for file in files: #遍历文件夹&#xA;     if os.path.isfile(path+&amp;#34;\\&amp;#34;+file): &#xA;          f = open(path+&amp;#34;\\&amp;#34;+file,&amp;#39;r&amp;#39;) #打开文件&#xA;          str_f = f.readlines() &#xA;          str = &amp;#34;#pragma comment&amp;#34;&#xA;          if str in str_f:&#xA;               s.append(file) &#xA;print(s) #打印结果&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后顺利发生异常,UnicodeDecodeError:&amp;lsquo;gbk&amp;rsquo; codec can&amp;rsquo;t decode byte 0x99 in position 2613: illegal multibyte sequence&lt;/p&gt;&#xA;&lt;h3 id=&#34;python编码问题&#34;&gt;python编码问题&lt;/h3&gt;&#xA;&lt;h4 id=&#34;一些基本概念&#34;&gt;一些基本概念&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编码：将人类可识别的字符转换为机器可识别的字节码 / 字节序列&lt;/li&gt;&#xA;&lt;li&gt;解码：编码的反向过程叫解码&lt;/li&gt;&#xA;&lt;li&gt;字符集: 某个范围内字符的集合，不同的字符集规定了字符的个数，比如 ASCII 字符集总共有128个字符，包含了英文字母、阿拉伯数字、标点符号和控制符。而 GB2312 字符集定义了7445个字符，包含了绝大部分汉字字符。&lt;/li&gt;&#xA;&lt;li&gt;字符是以字节为存储单位保存在文件中，文件保存在内存 / 物理磁盘中&lt;/li&gt;&#xA;&lt;li&gt;编码和解码: 编码的过程是将字符转换成字节流，解码的过程是将字节流解析为字符。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;编码问题的解决&#34;&gt;编码问题的解决&lt;/h4&gt;&#xA;&lt;p&gt;python中使用open()函数,默认的解码方式取决于平台,在Windows平台下是gbk,如图&lt;/p&gt;</description>
    </item>
    <item>
      <title>爬虫原理</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;h3 id=&#34;什么是爬虫&#34;&gt;什么是爬虫&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;爬虫是请求网站提取数据的自动化程序&lt;/code&gt;&#xA;关键点:1.发送请求(HTTP请求)2.获取服务器响应的内容(HTML代码,Json字符串,二进制数据等)3.解析内容4.保存数据&lt;/p&gt;&#xA;&lt;h3 id=&#34;发送请求&#34;&gt;发送请求&lt;/h3&gt;&#xA;&lt;p&gt;我们在向服务器端发送的Request中包含哪些东西呢?&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;请求方式:主要是GET和POST两种请求方法,还有一些HEAD,PUT,DELETE等等。&lt;/li&gt;&#xA;&lt;li&gt;请求URL:URL的全程是统一资源定位符,一个网页文档,一个视频,一张图片都可以由此确定,浏览器在渲染网页过程中会使用到URL。&lt;/li&gt;&#xA;&lt;li&gt;请求头:包含了一些请求时需要的配置信息,比如User-Agent,Cookies等等.服务器会依据这些信息来判断请求是否合法&lt;/li&gt;&#xA;&lt;li&gt;请求体:在做POST请求时会需要请求体这一部分,以键值对的形式发送。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;服务器响应&#34;&gt;服务器响应&lt;/h3&gt;&#xA;&lt;p&gt;Response中包含哪些内容:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;状态码(标识响应状态):200(请求成功),404(请求的资源不存在),301(重定位),502(服务器处理错误)&lt;/li&gt;&#xA;&lt;li&gt;响应头:保存内容类型,内容长度,服务器信息,设置cookie等等.&lt;/li&gt;&#xA;&lt;li&gt;响应体:最主要部分,包含了请求的资源,比如图片,网页源代码等等.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;解析内容&#34;&gt;解析内容&lt;/h3&gt;&#xA;&lt;p&gt;可以通过JSON解析,正则表达式解析,利用python解析库来进行解析&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;为什么抓取的数据和浏览器中看到的不一样呢?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;浏览器会将拿到的数据进行渲染,故会有很大不同,为了解决这一问题,我们可以分析Ajax请求,利用webdriver等库来自动化操作浏览器,调用splash库来进行js渲染等.&lt;/p&gt;&#xA;&lt;h3 id=&#34;保存数据&#34;&gt;保存数据&lt;/h3&gt;&#xA;&lt;p&gt;可以存取为纯文本,图片,音视频,或者存到数据库中&lt;/p&gt;&#xA;&lt;h3 id=&#34;什么是正则表达式&#34;&gt;什么是正则表达式&lt;/h3&gt;&#xA;&lt;p&gt;正则表达式是对字符串操作的一种逻辑公式,由普通字符（例如字符a到z）以及特殊字符（称为&amp;quot;元字符&amp;quot;）组成文字模式,模式描述在搜索文本时要匹配的一个或多个字符串,正则表达式作为一个模板,将某个字符模式与所搜索的字符串进行匹配。&lt;/p&gt;&#xA;&lt;h3 id=&#34;正则表达式在爬虫编写中的作用&#34;&gt;正则表达式在爬虫编写中的作用&lt;/h3&gt;&#xA;&lt;p&gt;通过正则表达式提取出网页中的有用信息,是爬虫程序最原始最灵活的写法,后续衍生出了无穷多的变体.&lt;/p&gt;&#xA;&lt;h3 id=&#34;常见匹配模式&#34;&gt;常见匹配模式&lt;/h3&gt;&#xA;&lt;p&gt;\w 匹配字母数字及下划线&#xA;\W 匹配非字母数字下划线&#xA;\s 匹配空白字符,等价于[\t\n\r\f]&#xA;\S 匹配非空白字符&#xA;\d 匹配数字,等价于[0-9]&#xA;\D 匹配任意非数字&#xA;^ 匹配字符串的开头&#xA;$ 匹配字符串的末尾&#xA;. 匹配任意除换行符以外的字符&#xA;[&amp;hellip;] 匹配中括号中包含的字符&#xA;[^&amp;hellip;] 匹配除中括号包含的字符以外的任意字符&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匹配0个或多个表达式,贪婪匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匹配1个或多个表达式,贪婪匹配&#xA;? 匹配0个或者1个字符,非贪婪匹配&#xA;{n} 匹配n个前面的表达式.&#xA;{n,m} 匹配n次到m次前面的表达式,贪婪匹配&#xA;a|b 匹配a或b&#xA;() 匹配括号内的表达式,也表示一个组&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>MD语法介绍</title>
      <link>http://localhost:1313/posts/%E6%9D%82%E9%A1%B9/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%9D%82%E9%A1%B9/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>&lt;p&gt;1、标题的写法：&lt;/p&gt;&#xA;&lt;h1 id=&#34;这是一级标题&#34;&gt;这是一级标题&lt;/h1&gt;&#xA;&lt;h2 id=&#34;这是二级标题&#34;&gt;这是二级标题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;这是三级标题&#34;&gt;这是三级标题&lt;/h3&gt;&#xA;&lt;h4 id=&#34;这是四级标题&#34;&gt;这是四级标题&lt;/h4&gt;&#xA;&lt;h5 id=&#34;这是五级标题&#34;&gt;这是五级标题&lt;/h5&gt;&#xA;&lt;h6 id=&#34;这是最低的六级标题&#34;&gt;这是最低的六级标题&lt;/h6&gt;&#xA;&lt;p&gt;2、列表&#xA;无序列表可以用用* ， + ， —三种符号来创建&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列表元素1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列表元素2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列表元素3&#xA;有序列表用数字直接创建&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;列表元素1&lt;/li&gt;&#xA;&lt;li&gt;列表元素2&lt;/li&gt;&#xA;&lt;li&gt;列表元素3&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;3、区块引用&#xA;比如说，你想对某个部分做的内容做一些说明或者引用某某的话等，可以进行区块引用&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;谁终将声震人间，必长久深自缄默。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;尼采他老人家说的&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其实后面还有一句的。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;4、华丽的分割线&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;看见上面那个没，那就是华丽丽的分割线&lt;/p&gt;&#xA;&lt;p&gt;5、链接&#xA;有2种链接方式：行内式和参数式&#xA;&lt;a href=&#34;http://www.google.com&#34;&gt;行内式&lt;/a&gt;即这是一个行内式&#xA;参数式&lt;/p&gt;&#xA;&lt;p&gt;6、图片加载&#xA;&lt;img src=&#34;https://img2018.cnblogs.com/blog/1197364/201908/1197364-20190826182458729-2062223622.png&#34; alt=&#34;这是一个图片&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;7、代码&#xA;&lt;code&gt;print(&amp;quot;hello world!&amp;quot;)&lt;/code&gt;&#xA;这是多行注释&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;&#xA;int main()&#xA;{&#xA;    printf(&amp;#34;Hello World!&amp;#34;);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8、表格&#xA;介绍一种比较好写的表格写法&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;学生姓名&lt;/th&gt;&#xA;          &lt;th&gt;分数&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;小明&lt;/td&gt;&#xA;          &lt;td&gt;90&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;小红&lt;/td&gt;&#xA;          &lt;td&gt;99&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;小浩&lt;/td&gt;&#xA;          &lt;td&gt;100&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;9、强调&#xA;一个星号或者是一个下划线包起来，会转换为 &amp;lt;em&amp;gt; 倾斜，如果是2个，会转换为 &amp;lt;strong&amp;gt; 加粗&#xA;&lt;del&gt;删除掉我吧&lt;/del&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>突发奇想的THANOS程序</title>
      <link>http://localhost:1313/posts/%E6%9D%82%E9%A1%B9/python%E9%9A%8F%E6%9C%BA%E5%88%A0%E9%99%A4/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%9D%82%E9%A1%B9/python%E9%9A%8F%E6%9C%BA%E5%88%A0%E9%99%A4/</guid>
      <description>&lt;h3 id=&#34;随机删除脚本&#34;&gt;随机删除脚本&lt;/h3&gt;&#xA;&lt;p&gt;这几天看了复仇者联盟４，忽然有点想写一个灭霸程序，双击打开输入路径后一半的文件灰飞烟灭。&lt;/p&gt;&#xA;&lt;p&gt;具体实现代码如下:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os&#xA;import random&#xA;import shutil&#xA;&#xA;def thanos(dir_path):&#xA;    files = os.listdir(dir_path) # 列出目录下文件&#xA;    sample = random.sample(files, len(files) // 2) # 随机选取k个元素组成新的列表&#xA;    for item in sample:&#xA;        file_path = os.path.join(dir_path,item)&#xA;        try:&#xA;            if(os.path.isfile(file_path)):&#xA;                os.remove(file_path)&#xA;            elif(os.path.isdir(file_path)):&#xA;                shutil.rmtree(file_path)&#xA;        except PermissionError as e:&#xA;                pass&#xA;&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    path = input(&amp;#34;please input file path:&amp;#34;)&#xA;    if(path == &amp;#39;&amp;#39;):&#xA;        path = os.getcwd() # 获取目录&#xA;    thanos(path)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;顺便比较一下这几种删除函数&#34;&gt;顺便比较一下这几种删除函数&lt;/h4&gt;&#xA;&lt;p&gt;os.remove(),os.unlink(),os.removedirs(),shutil.rmtree()这几个函数都有删除的功能，区别如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;os.remove()和os.unlink()这两个函数功能是一样的，都是删除一个文件。&lt;/li&gt;&#xA;&lt;li&gt;os.removedirs()是递归删除空文件夹，即先删除子目录再尝试删除父目录，如果目录是空的则进行删除操作。&lt;/li&gt;&#xA;&lt;li&gt;shutil.rmtree()表示递归删除文件夹下的所有子文件夹和子文件而不管是否为空。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
