<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Windows机制 on huolong blog</title>
    <link>https://6uolong.github.io/categories/windows%E6%9C%BA%E5%88%B6/</link>
    <description>Recent content in Windows机制 on huolong blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 19 Mar 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://6uolong.github.io/categories/windows%E6%9C%BA%E5%88%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>NT驱动框架</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;h3 id=&#34;驱动模型&#34;&gt;驱动模型&lt;/h3&gt;&#xA;&lt;p&gt;NT模型&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DriverEntry()&lt;/li&gt;&#xA;&lt;li&gt;DispathCreate()-&amp;gt;IRP_MJ_CREATE&lt;/li&gt;&#xA;&lt;li&gt;DispathRead()-&amp;gt;IRP_MJ_READ&lt;/li&gt;&#xA;&lt;li&gt;DispathWrite()-&amp;gt;IRP_MJ_WRITE&lt;/li&gt;&#xA;&lt;li&gt;DispathClose()-&amp;gt;IRP_MJ_CLOSE(FileObject引用为0)&lt;/li&gt;&#xA;&lt;li&gt;Dispathclean()-&amp;gt;IRP_MJ_CLEANUP(Handle引用为0)&lt;/li&gt;&#xA;&lt;li&gt;DispathControl()-&amp;gt;IRP_MJ_DEVICE_CONTROL&lt;/li&gt;&#xA;&lt;li&gt;DriverUnload()&#xA;IRP是IO Request Packet,是由r3层传输来的信息包装之后的产物,一种分发函数会处理相应的IRP请求,在驱动开发中,IRP本质是一个很大的结构体,分为头部和栈两部分,具体结构可在VS中看到。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;调用IoCreateDevice函数创建设备对象&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PDEVICE_OBJECT DeviceObject;&#xD;&#xA;NTSTATUS status = IoCreateDevice(DriverObject,&#xD;&#xA;     sizeof(DEVICE_EXTENSION),&#xD;&#xA;     NULL,&#xD;&#xA;     FILE_DEVICE_UNKNOWN,&#xD;&#xA;     FILE_DEVICE_SECURE_OPEN,&#xD;&#xA;     FALSE,&#xD;&#xA;     &amp;amp;DeviceObject);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个参数(DriverObject),该参数用于在驱动程序和新设备对象之间建立连接,这样I/O管理器就可以向设备发送指定的IRP。&lt;/p&gt;&#xA;&lt;p&gt;第二个参数是设备扩展结构的大小。I/O管理器自动分配这个内存,并把设备对象中的DeviceExtension指针指向这块内存。&lt;/p&gt;&#xA;&lt;p&gt;第三个参数在本例中为NULL。它可以是命名该设备对象的UNICODE_STRING串的地址。决定是否命名设备对象以及以什么名字命名还需要仔细考虑,我将在本节后面深入讨论这个问题。&lt;/p&gt;&#xA;&lt;p&gt;第四个参数(FILE_DEVICE_UNKNOWN) 是设备类型。这个值可以被设备硬件键或类键中的超越值所替代,如果这两个键都含有该参数的超越值,那么硬件键中的超越值具有更高的优先权。对于属于某个已存在类的设备,必须在这些地方指定正确的值,因为驱动程序与外围系统的交互需要依靠这个值。另外,设备对象的默认安全设置也依靠这个设备类型值。&lt;/p&gt;&#xA;&lt;p&gt;第五个参数(FILE_DEVICE_SECURE_OPEN) 为设备对象提供Characteristics标志。这些标志主要关系到块存储设备(如软盘、CDROM、Jaz等等)。未公开标志位FILE_AUTOGENERATED_DEVICE_NAME仅用于内部使用,并不是DDK文档忘记提到该标志。这个参数同样也能被硬件键或类键中的对应值超越,如果两个值都存在,那么硬件键中的超越值具有更高的优先权。&lt;/p&gt;&#xA;&lt;p&gt;第六个参数(FALSE) 指出设备是否是排斥的。通常,对于排斥设备,I/O管理器仅允许打开该设备的一个句柄。这个值同样也能被注册表中硬件键和类键中的值超越,如果两个超越值都存在,硬件键中的超越值具有更高的优先权。&lt;/p&gt;&#xA;&lt;p&gt;通常设备对象都把自己的名字放到/Device目录中。在Windows 2000中,设备的名称有两个用途。第一个用途,设备命名后,其它内核模式部件可以通过调用IoGetDeviceObjectPointer函数找到该设备,找到设备对象后,就可以向该设备的驱动程序发送IRP。&#xA;另一个用途,允许应用程序打开命名设备的句柄,这样它们就可以向驱动程序发送IRP。应用程序可以使用标准的CreateFile API打开命名设备句柄,然后用ReadFile、WriteFile,和DeviceIoControl向驱动程序发出请求。应用程序打开设备句柄时使用//./路径前缀而不是标准的UNC(统一命名约定)名称,如C:/MYFILE.CPP或//FRED/C-Drive/HISFILE.CPP。在内部,I/O管理器在执行名称搜索前自动把//./转换成/??/。为了把/??目录中的名字与名字在其它目录(例如,在/Device目录)中的对象相连接,对象管理器实现了一种称为符号连接(symbolic link)的对象。&lt;/p&gt;</description>
    </item>
    <item>
      <title>汇编中的寄存器</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description>&lt;h3 id=&#34;汇编中各式各样的寄存器&#34;&gt;汇编中各式各样的寄存器&lt;/h3&gt;&#xA;&lt;p&gt;通用寄存器:eax,ebx,ecx,edx&#xA;源变址和目标变址寄存器:ESI,EDI&#xA;栈相关寄存器:SS,ESP,EBP&#xA;代码段相关寄存器:CS,EIP&#xA;数据段相关寄存器:DS(常与ESI寄存器结合使用)&#xA;附加段寄存器:ES(常与EDI寄存器结合使用)&#xA;控制寄存器:CR0-CR3&#xA;系统地址寄存器:GDTR,LDTR,IDTR,TR&lt;/p&gt;&#xA;&lt;p&gt;Flag寄存器标志位含义:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ZF零标志,用来反映运算结果是否为零,如果为零则该标志位置为1&lt;/li&gt;&#xA;&lt;li&gt;AF辅助进位标志,运算过程中第三位有进位,则置为1&lt;/li&gt;&#xA;&lt;li&gt;PF奇偶标志,当运算结果中有偶数个1时,置为1&lt;/li&gt;&#xA;&lt;li&gt;SF符号标志,当运算结果为负数时,置为1&lt;/li&gt;&#xA;&lt;li&gt;CF进位标志,最高有效位产生进位时,置为1&lt;/li&gt;&#xA;&lt;li&gt;OF溢出标志,若操作数结果超出了机器能够表示的范围,则产生溢出,置为1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;cisc汇编和risc汇编&#34;&gt;CISC汇编和RISC汇编&lt;/h3&gt;&#xA;&lt;p&gt;CISC与RISC主要区别&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;比较内容&lt;/th&gt;&#xA;          &lt;th&gt;CISC&lt;/th&gt;&#xA;          &lt;th&gt;RISC&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令系统&lt;/td&gt;&#xA;          &lt;td&gt;复杂,庞大&lt;/td&gt;&#xA;          &lt;td&gt;精简&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令数目&lt;/td&gt;&#xA;          &lt;td&gt;一般大于200&lt;/td&gt;&#xA;          &lt;td&gt;一般小于100&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令长度&lt;/td&gt;&#xA;          &lt;td&gt;不固定&lt;/td&gt;&#xA;          &lt;td&gt;等长&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;可访存指令&lt;/td&gt;&#xA;          &lt;td&gt;不加限制&lt;/td&gt;&#xA;          &lt;td&gt;只有load和store&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令使用频率&lt;/td&gt;&#xA;          &lt;td&gt;相差很大&lt;/td&gt;&#xA;          &lt;td&gt;相差不大&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;指令执行时间&lt;/td&gt;&#xA;          &lt;td&gt;相差很大&lt;/td&gt;&#xA;          &lt;td&gt;大多在一个周期完成&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;优化编译实现&lt;/td&gt;&#xA;          &lt;td&gt;很难&lt;/td&gt;&#xA;          &lt;td&gt;较为容易&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;程序源代码长度&lt;/td&gt;&#xA;          &lt;td&gt;较短&lt;/td&gt;&#xA;          &lt;td&gt;较长&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;控制器实现方式&lt;/td&gt;&#xA;          &lt;td&gt;绝大多数为微程序控制&lt;/td&gt;&#xA;          &lt;td&gt;绝大多数为硬布线控制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;系统软件开发时间&lt;/td&gt;&#xA;          &lt;td&gt;较短&lt;/td&gt;&#xA;          &lt;td&gt;较长&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;CISC指令集复杂丰富,功耗大,每条指令长度也不固定(1-6个字节),不适用于移动端,因此移动端几乎被RISC占据&lt;/li&gt;&#xA;&lt;li&gt;在RISC中,CPU并不会对内存中的数据进行操作,所有的计算都要求在寄存器中完成,而寄存器和内存的通信则由单独指令完成,CISC中CPU可以直接对内存操作&lt;/li&gt;&#xA;&lt;li&gt;RISC拥有更多的通用寄存器,每个寄存器都可以用作数据存储和寻址&lt;/li&gt;&#xA;&lt;li&gt;RISC指令集能够非常有效地采用流水线,超流水线和超标量技术,实现指令级的并行操作,从而提高效率&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;x86指令讲解&#34;&gt;x86指令讲解&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;mov指令&#xA;格式:mov reg/mem, reg/mem/imme&#xA;注意:段寄存器不能直接用mov指令传送,以下指令是错误的&#xA;mov ds, es&#xA;mov ds, 5&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;常见汇编指令与机器码&#34;&gt;常见汇编指令与机器码&lt;/h3&gt;&#xA;&lt;p&gt;short jump -&amp;gt; eb (8位)&#xA;near jump -&amp;gt; e9 (16位)&#xA;far jump -&amp;gt; ea (32位)&#xA;je/jz -&amp;gt; 74&#xA;jne/jnz -&amp;gt; 75&#xA;nop -&amp;gt; 90&#xA;int 3 -&amp;gt; cc&#xA;ret -&amp;gt; c3&#xA;call eax -&amp;gt; d0ff&#xA;jmp esp -&amp;gt; e4ff&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows系统下各种链接</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sun, 29 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E9%93%BE%E6%8E%A5/</guid>
      <description>&lt;h3 id=&#34;0x00-硬链接&#34;&gt;0x00 硬链接&lt;/h3&gt;&#xA;&lt;p&gt;和GNU/Linux相同的是，Windows也有自己的链接创建工具mklink。Windows下的硬链接只允许在NTFS格式的文件系统下创建（通过CreateHardLink()系统调用），并且和Linux一样，硬链接的创建只能针对文件，而不能针对目录。&lt;/p&gt;&#xA;&lt;p&gt;创建硬链接的命令时mklink /H &amp;lt; destination &amp;gt; &amp;lt; source &amp;gt;，在创建后的图标也和原文件的图标一样，在属性中也无法看出其中的链接关系。唯一的方法就是通过fsutil hardlink list &amp;lt; filepath &amp;gt;来查看一个文件包含了多少硬链接。创建硬链接后，文件属性显示空间占用是与原文件大小相同的，但是实际上它并没有占用空间，真实的空间占用为0，硬链接不会把文件再复制一份。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x01-符号链接&#34;&gt;0x01 符号链接&lt;/h3&gt;&#xA;&lt;p&gt;创建符号（软）链接的命令为mklink &amp;lt; destination &amp;gt; &amp;lt; source &amp;gt;，也就是不为mklink提供其他的参数。建立之后，我们会发现软链接图标带有一个快捷方式样式的箭头，但是其文件属性的类型仍为原来的文件类型，Size却为0，并且有很多项都是灰色disable状态。&#xA;但是需要说明的是，通过这种方式建立软链接只能针对文件建立。如果需要给文件夹建立软链接，那么就需要通过加入/D参数来建立，详情见mklink命令说明。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x02-junction链接&#34;&gt;0x02 junction链接&lt;/h3&gt;&#xA;&lt;p&gt;Junction是Windows NTFS特有的一种链接方式。Junction和软链接类似，也是通过记录文件路径来访问文件。但是首先，Junction只针对文件夹，我们不能为文件建立Junction；其次，当我们删除Junction链接后，原文件夹也会被删除。Junction最常用的地方是用户目录下，我们会看到一些带有快捷方式图标的隐藏文件夹，但是当我们试图去访问的时候，则会被拒绝（即使是管理员也不行）。&lt;/p&gt;&#xA;&lt;p&gt;我们可以通过mklink /J &amp;lt; destination &amp;gt; &amp;lt; source &amp;gt;命令来建立Junction。在直观看来，Junction似乎也是介于软硬链接之间的一种奇葩存在，比如Junction的图标是带有箭头的，但是在文件夹的属性中，却看不到类似于软链接的那种shortcut选项卡，更像是硬链接的感觉。&lt;/p&gt;&#xA;&lt;p&gt;实际上，Windows之所以要在用户目录下面建立诸多的Junction的目的就在于和老版本的软件兼容。我们知道在xp时代，程序数据通常储存在Application Data文件夹中，但是当Windows转向Vista时，目录名和位置都有所变化，变成了AppData，这样，对于以前的硬编码安装路径的程序，就会遇到安装错误的问题。于是MS决定通过Junction的方式来解决。这样当某个程序访问或写入Application Data时，其所访问的是AppData文件夹，这样就避免了版本不兼容的问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x03-快捷方式&#34;&gt;0x03 快捷方式&lt;/h3&gt;&#xA;&lt;p&gt;其实我们最熟悉也是最常用的快捷方式并不属于传统概念上的“链接”。虽然似乎快捷方式有点类似于软链接，但是它们的本质还是非常不同的。链接其实更贴近操作系统和文件系统的概念。而快捷方式，其实是一个真真实实的以lnk作为文件类型的文件。只不过操作系统（更确切的说是Windows的shell，explorer）可以对这种lnk文件解释而已。而快捷方式的功能其实也要比传统的Linux或WIndows的软链接的功能更强大一些。如果我们打开一个快捷方式的属性，我们就会发现原来在软链接的属性中不可修改的部分都变成了可以修改的，这里面包含了文件的打开方式，快捷键，以何种窗口模式打开等属性。&lt;/p&gt;&#xA;&lt;p&gt;也就是说，快捷方式不同于软链接的地方，就是它不仅仅是个包含文件路径的文件，而是增加了许多其他信息。这种和窗口化相关的信息如果基于文件系统自然是非常不便的，所以MS就单独设计了lnk文件，由explorer来执行。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x04-总结与区别&#34;&gt;0x04 总结与区别&lt;/h3&gt;&#xA;&lt;p&gt;所谓硬链接，我们可以理解为硬链接持有的是文件本身（而不是路径）的引用。也就是说，当我们给一个名为a.txt的文件建立硬链接（b.txt）后，那么b.txt指向的位置就是a.txt这个文件本身，而此时，a.txt和b.txt是同级平行的，这个文本文件此时同时拥有两个文件名。当我们删除a.txt时，只是删除了a.txt这个文件名，这个文件仍然被b.txt所引用，所以我们还能够通过b.txt访问。而软链接，持有的则是原链接路径。比如a.txt位于 ../Document/a.txt ，那么为其建立软链接b.txt的内容就是 ../Document/a.txt，此时，我们访问b.txt，其实是在按照a.txt的路径去访问a.txt。如果我们这时删除a.txt这个文件，那么b.txt也会无效，因为文件已经不存在了。&lt;/p&gt;&#xA;&lt;p&gt;而junction链接则是介于软链接和硬链接之间的一种为了解决向下兼容问题的独特链接，快捷方式则是对软链接的一种补充，ink格式的文件提供了我们对打开方式修改的能力。&lt;/p&gt;&#xA;&lt;h3 id=&#34;关于winsxs的补充&#34;&gt;关于WinSxS的补充&lt;/h3&gt;&#xA;&lt;p&gt;WinSxS位于%systemroot%\WinSxS，其中存放的是Windows系统文件以及DLL文件的若干个副本。由于应用程序可以使用同一个DLL文件，因此出于兼容性与还原至旧版本的考虑，系统会在这里存放多个不同版本的文件副本。&lt;/p&gt;&#xA;&lt;p&gt;使用一些硬链接查看的工具可以发现，Windows当中的大部分系统文件都是该目录下文件的硬链接。因此该目录是系统正常运行不可或缺的。&#xA;为一个文件创造硬链接后使用fsutil工具查看会显示出原文件和目标文件的路径。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;hardlink1.png&#34; alt=&#34;&#34;&gt;&lt;img src=&#34;hardlink2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SecureBoot机制</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/secureboot%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/secureboot%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h3 id=&#34;从用户态恶意软件说起&#34;&gt;从用户态恶意软件说起&lt;/h3&gt;&#xA;&lt;p&gt;随着攻防技术在对抗中彼此不断进步,微软在对用户态恶意软件的防护已经很成熟了,对于微软商店中的软件(虽然微软商店的软件不是主流,涵盖的软件也相对较少,但这是一种趋势),本身就是运行在沙盒环境中,很难掀起什么风浪,而对于传统的桌面端软件,有Windows defender的签名检测,smartscreen对于不信任软件的提醒,以及uac对软件提权请求的拦截。&lt;/p&gt;&#xA;&lt;p&gt;对于内核态恶意软件呢?用户态的恶意软件能做的事情其实很有限,只有到达内核态,与操作系统拥有相同的权限,才能做更多的事情,微软对这些rootkits有哪些防御措施&lt;/p&gt;&#xA;&lt;h3 id=&#34;rootkit的简明分类&#34;&gt;rootkit的简明分类&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Firmware rootkit:这种恶意软件通过patch BIOS以及其他固件,达到在Windows之前启动的目的,从而达到隐藏和进行恶意操作的目的&lt;/li&gt;&#xA;&lt;li&gt;Bootkit:对bootloader动手脚,bootloader是引导Windows系统的一个关键程序,以达到在Windows之前启动的目的&lt;/li&gt;&#xA;&lt;li&gt;Kernel rootkit:替换部分Windows的系统关键驱动,以便达到和Windows一起启动的效果&lt;/li&gt;&#xA;&lt;li&gt;Driver rootkit:伪装成受Windows信任的第三方驱动程序,进行恶意活动&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;对应措施&#34;&gt;对应措施&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Secure Boot:带有UEFI固件和可信平台模块(TPM)的PC可以配置为只加载可信操作系统引导加载程序&lt;/li&gt;&#xA;&lt;li&gt;Trusted Boot:Windows会在加载启动之前检查每个组件的完整性。&lt;/li&gt;&#xA;&lt;li&gt;Early Launch Anti-Malware (ELAM):在加载之前,杀毒驱动会先加载测试所有驱动程序,并防止未经批准的驱动程序加载。&lt;/li&gt;&#xA;&lt;li&gt;Measured Boot:PC的固件记录引导过程可以被发送到可信的服务器,从而客观地评估PC的健康状况&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;一些细节&#34;&gt;一些细节&lt;/h3&gt;&#xA;&lt;p&gt;当装有UEFI的PC启动时,PC首先验证固件是数字签名的,从而降低firmware rootkit的风险。如果启用了secure boot,固件将检查bootloader的数字签名,以保证它没有被修改,并在随后检查其是否有受信任证书,如果这些成功,secure boot的工作就完成了,对于secure boot来说,它可以使用TPM但不要求必须有TPM,而Measured Boot则需要TPM支持&lt;/p&gt;&#xA;&lt;p&gt;之后,bootloader在加载内核之前会对其进行数字签名验证, 随后内核依次验证Windows启动过程中的所有其他组件,包括启动驱动程序,启动文件和ELAM等,如果文件已被修改则拒绝加载损坏的组件,Windows 10通常可以自动修复损坏的组件,恢复Windows的完整性并允许PC正常启动&lt;/p&gt;&#xA;&lt;p&gt;ELAM说白了就是在加载一些第三方驱动之前最先加载杀毒软件的驱动,这样一来恶意软件即使伪装成驱动,权限也不会有杀毒软件的高,杀毒软件可以轻松干掉它,从而继续这条信任链。 由于操作系统尚未启动，并且Windows需要尽快启动，因此ELAM的任务很简单：检查每个要加载的驱动并确定其是否在受信任的驱动程序列表中,如果不受信任,就不会加载它。&lt;/p&gt;&#xA;&lt;p&gt;至于Measured Boot,没有TPM的情况下不会生效&lt;/p&gt;</description>
    </item>
    <item>
      <title>msvcrt的链接</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/msvcrt%E7%9A%84%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/msvcrt%E7%9A%84%E9%93%BE%E6%8E%A5/</guid>
      <description>&lt;h3 id=&#34;运行时库&#34;&gt;运行时库&lt;/h3&gt;&#xA;&lt;p&gt;运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件，从形式上来讲和我们自己开发的静态库、动态库没什么两样，只是它们由微软开发和维护，并提供了一些常用的功能支持（如malloc,free, printf等等），如果我们的程序需要使用这些功能（事实上，只要是C/C++程序就一定会用到运行时库提供的功能），就要链接C/C++运行时库。上次弄了半天也没找到链接msvcrt的方法,今天在又一次学习静态库和静态库的时候发现了.&lt;/p&gt;&#xA;&lt;p&gt;这是c语言链接的方式,VS已经在背地里偷偷帮你做了,你只需要#include&amp;lt;头文件&amp;gt;就可以调用函数了,通过命令行命令VS自动帮你#pragma comment()了.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;C语言标准库&lt;/th&gt;&#xA;          &lt;th&gt;特征&lt;/th&gt;&#xA;          &lt;th&gt;选项&lt;/th&gt;&#xA;          &lt;th&gt;预处理器指令&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcmt.lib&lt;/td&gt;&#xA;          &lt;td&gt;将本机 CRT 启动静态链接到你的代码。&lt;/td&gt;&#xA;          &lt;td&gt;/MT&lt;/td&gt;&#xA;          &lt;td&gt;_MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcmtd.lib&lt;/td&gt;&#xA;          &lt;td&gt;静态链接本机 CRT 启动的调试版本。 不可再发行。&lt;/td&gt;&#xA;          &lt;td&gt;/MTd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcrt.lib 和 msvcrxxx.dll&lt;/td&gt;&#xA;          &lt;td&gt;与 DLL UCRT 和 vcruntime 一起使用的本机 CRT 启动的静态库。&lt;/td&gt;&#xA;          &lt;td&gt;/MD&lt;/td&gt;&#xA;          &lt;td&gt;_MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcrtd.lib 和 msvcrxxxd.dll&lt;/td&gt;&#xA;          &lt;td&gt;与 DLL UCRT 和 vcruntime 一起使用的本机 CRT 启动调试版本的静态库, 不可再发行。&lt;/td&gt;&#xA;          &lt;td&gt;/MDd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;下面是C++运行时的标准库链接方法&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;C++ 标准库&lt;/th&gt;&#xA;          &lt;th&gt;特征&lt;/th&gt;&#xA;          &lt;th&gt;选项&lt;/th&gt;&#xA;          &lt;th&gt;预处理器指令&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcpmt.lib&lt;/td&gt;&#xA;          &lt;td&gt;多线程, 静态链接&lt;/td&gt;&#xA;          &lt;td&gt;/MT&lt;/td&gt;&#xA;          &lt;td&gt;_MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcprt.lib 和 msvcpxxx.dll&lt;/td&gt;&#xA;          &lt;td&gt;多线程动态链接（MSVCPversion.dll 的导入库）&lt;/td&gt;&#xA;          &lt;td&gt;/MD&lt;/td&gt;&#xA;          &lt;td&gt;_MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;libcpmtd.lib&lt;/td&gt;&#xA;          &lt;td&gt;多线程, 静态链接&lt;/td&gt;&#xA;          &lt;td&gt;/MTd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;msvcprtd.lib 和 msvcpxxxd.dll&lt;/td&gt;&#xA;          &lt;td&gt;多线程动态链接（MSVCPversionD.DLL 的导入库）&lt;/td&gt;&#xA;          &lt;td&gt;/MDd&lt;/td&gt;&#xA;          &lt;td&gt;_DEBUG, _MT, _DLL&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;xxx代表版本,cp的意思就是c++,d就是debug版本的意思,最后没有d就是release版了.&#xA;同样也是VS偷偷帮我们做的.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ntdll提权函数使用</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/ntdll%E5%86%85%E7%9A%84%E6%8F%90%E6%9D%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/ntdll%E5%86%85%E7%9A%84%E6%8F%90%E6%9D%83%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h3 id=&#34;rtladjustprivilege函数略解&#34;&gt;RtlAdjustPrivilege函数略解&lt;/h3&gt;&#xA;&lt;p&gt;NTSTATUS RtlAdjustPrivilege&#xA;(&#xA;ULONG Privilege,&#xA;BOOLEAN Enable,&#xA;BOOLEAN CurrentThread,&#xA;PBOOLEAN Enabled&#xA;)&lt;/p&gt;&#xA;&lt;p&gt;参数的含义：&#xA;Privilege [In] Privilege index to change.&#xA;// 所需要的权限名称，可以到 MSDN 查找关于 Process Token &amp;amp; Privilege 内容可以查到&lt;/p&gt;&#xA;&lt;p&gt;Enable [In] If TRUE, then enable the privilege otherwise disable.&#xA;// 如果为True 就是打开相应权限，如果为False 则是关闭相应权限&lt;/p&gt;&#xA;&lt;p&gt;CurrentThread [In] If TRUE, then enable in calling thread, otherwise process.&#xA;// 如果为True 则仅提升当前线程权限，否则提升整个进程的权限&lt;/p&gt;&#xA;&lt;p&gt;Enabled [Out] Whether privilege was previously enabled or disabled.&#xA;// 输出该权限之前的状态是开启还是关闭&lt;/p&gt;&#xA;&lt;p&gt;权限ID对应的字码以及描述&#xA;1.SeCreateTokenPrivilege 0x2 Create a token object&#xA;2.SeAssignPrimaryTokenPrivilege 0x3 Replace a process level token&#xA;3.SeLockMemoryPrivilege 0x4 Lock pages in memory&#xA;4.SeIncreaseQuotaPrivilege 0x5 Adjust memory quotas for a process&#xA;5.SeUnsolicitedInputPrivilege 0x0&#xA;6.SeMachineAccountPrivilege 0x6&#xA;7.SeTcbPrivilege 0x7 Act as part of the operating system&#xA;8.SeSecurityPrivilege 0x8 Manage auditing and security log&#xA;9.SeTakeOwnershipPrivilege 0x9 Take ownership of files or other objects&#xA;10.SeLoadDriverPrivilege 0xa Load and unload device drivers&#xA;11.SeSystemProfilePrivilege 0xb Profile system performance&#xA;12.SeSystemtimePrivilege 0xc Change the system time&#xA;13.SeProfileSingleProcessPrivilege 0xd Profile single process&#xA;14.SeIncreaseBasePriorityPrivilege 0xe Increase scheduling priority&#xA;15.SeCreatePagefilePrivilege 0xf Create a pagefile&#xA;16.SeCreatePermanentPrivilege 0x10 Create permanent shared objects&#xA;17.SeBackupPrivilege 0x11&#xA;18.SeRestorePrivilege 0x12&#xA;19.SeShutdownPrivilege 0x13&#xA;20.SeDebugPrivilege 0x14&#xA;21.SeAuditPrivilege 0x15 Generate security audits&#xA;22.SeSystemEnvironmentPrivilege 0x16 Modify firmware environment values&#xA;23.SeChangeNotifyPrivilege 0x17 Bypass traverse checking&#xA;24.SeRemoteShutdownPrivilege 0x18&#xA;25.SeUndockPrivilege 0x19 Remove computer from docking station   &lt;br&gt;&#xA;26.SeSyncAgentPrivilege 0x1a&#xA;27.SeEnableDelegationPrivilege 0x1b&#xA;28.SeManageVolumePrivilege 0x1c Perform volume maintenance tasks&#xA;29.SeImpersonatePrivilege 0x1d Impersonate a client after authentication&#xA;30.SeCreateGlobalPrivilege 0x1e&#xA;31.SeTrustedCredManAccessPrivilege 0x1f Access Credential Manager as a trusted caller&#xA;32.SeRelabelPrivilege 0x20 Modify an object label&#xA;33.SeIncreaseWorkingSetPrivilege 0x21 Increase a process working set&#xA;34.SeTimeZonePrivilege 0x22&#xA;35.SeCreateSymbolicLinkPrivilege 0x23&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86和x64汇编传参问题</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/confusing-x86-64/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/confusing-x86-64/</guid>
      <description>&lt;h3 id=&#34;先看看x86的传参&#34;&gt;先看看x86的传参&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;push eax&#xA;call xxx&#xA;&#xA;xxx fun proc&#xA;&#xA;push        ebp          保存栈底&#xA;mov         ebp,esp      设置ebp&#xA;sub         esp,0C0h     开辟局部变量空间&#xA;push        ebx          保存寄存器环境&#xA;push        esi  &#xA;push        edi  &#xA;&#xA;pop         edi          恢复寄存器环境&#xA;pop         esi  &#xA;pop         ebx          &#xA;mov         esp,ebp      释放局部变量空间&#xA;pop         ebp          恢复栈底&#xA;ret                      返回,平栈,如果是c的调用方式 则add esp,xxx在外部平栈, stdcall 则内部平栈 ret 4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结一下就是:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;往栈中存放参数&lt;/li&gt;&#xA;&lt;li&gt;将返回地址入栈&lt;/li&gt;&#xA;&lt;li&gt;保存栈底&lt;/li&gt;&#xA;&lt;li&gt;栈内部进行自己的 申请空间 保存环境 以及释放.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;再看看x64下的参数传递&#34;&gt;再看看x64下的参数传递&lt;/h3&gt;&#xA;&lt;p&gt;调用者部分:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sub rsp,0x28&#xA;mov r9,1&#xA;mov r8,2&#xA;mov rdx,3&#xA;mov rcx,4&#xA;call xxx&#xA;add rsp,0x28&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;被调函数:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;xxx                 &#xA;&#xA;mov qword ptr [rsp + 0x20],r9&#xA;mov qword ptr [rsp + 0x18],r8&#xA;mov qword ptr [rsp + 0x10],rdx&#xA;mov qword ptr [rsp + 8],rcx&#xA;push rbp&#xA;&#xA;xxx &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:&lt;/p&gt;</description>
    </item>
    <item>
      <title>dll注入与hook</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/dll%E6%B3%A8%E5%85%A5%E5%92%8Chook/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/dll%E6%B3%A8%E5%85%A5%E5%92%8Chook/</guid>
      <description>&lt;h3 id=&#34;使用dll的方法&#34;&gt;使用dll的方法&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;隐式链接(lib+dll+头文件)&#xA;#pragma comment(lib,&amp;ldquo;libname.lib&amp;rdquo;)&#xA;#include&amp;lt;libname.h&amp;gt;&#xA;调用&lt;/li&gt;&#xA;&lt;li&gt;只有dll文件(显式链接)&#xA;LoadLibrary hModule&#xA;GetProcAddress funcName&#xA;FreeLibrary&#xA;或在.h文件中: extern &amp;ldquo;C&amp;rdquo; funcName()&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在动态链接库项目被编译后,会生成lib文件和dll文件&#xA;.lib文件: 存储了导出函数的名称和位置&#xA;.dll文件: 包含实际的函数代码和数据&lt;/p&gt;&#xA;&lt;h3 id=&#34;dll劫持&#34;&gt;dll劫持&lt;/h3&gt;&#xA;&lt;p&gt;原理:程序调用loadlibrary载入库时,如果使用了相对路径,可能会加载同名其他恶意dll&#xA;dll加载目录搜索顺序:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序所在目录&lt;/li&gt;&#xA;&lt;li&gt;加载dll时所在的当前目录(比如在桌面打开图片,桌面就是当前目录)&lt;/li&gt;&#xA;&lt;li&gt;系统目录system32&lt;/li&gt;&#xA;&lt;li&gt;Windows目录&lt;/li&gt;&#xA;&lt;li&gt;Path环境变量下的目录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;微软的应对措施:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开启safedllsearchmode,改变加载顺序,即将上表中的第二加载改为倒数第二加载&lt;/li&gt;&#xA;&lt;li&gt;注册表中knowndlls项规定了某些特殊的dll,这些dll必须在system32目录中寻找并加载&lt;/li&gt;&#xA;&lt;li&gt;微软还提供了一个ExcludeFromKnownDlls项,重启生效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;防御:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用绝对路径&lt;/li&gt;&#xA;&lt;li&gt;白名单,签名机制&lt;/li&gt;&#xA;&lt;li&gt;SetDllDirectory把当前目录一项去掉&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;全局钩子&#34;&gt;全局钩子&lt;/h3&gt;&#xA;&lt;p&gt;HHOOK WINAPI SetWindowsHookEx(&#xA;int idhook;\钩子类型&#xA;HOOKPROC lpfn;\回调函数地址&#xA;HINSTANCE hMod;\包含lpfn的实例句柄&#xA;DWORD dwThreadid;\线程ID,如果是零,则监控所有线程的全局钩子&#xA;)&#xA;钩子类型:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;值&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_CALLWNDPROC&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_CALLWNDPROCRET&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，在目标窗口过程处理消息后监视消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_CBT&lt;/td&gt;&#xA;          &lt;td&gt;安装接收对CBT应用程序有用的通知的挂钩程序。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_DEBUG&lt;/td&gt;&#xA;          &lt;td&gt;安装可用于调试其他挂钩程序的挂钩程序。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_FOREGROUNDIDLE&lt;/td&gt;&#xA;          &lt;td&gt;安装将在应用程序的前台线程即将变为空闲时调用的钩子过程。该挂钩对于在空闲时执行低优先级任务很有用。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_GETMESSAGE&lt;/td&gt;&#xA;          &lt;td&gt;安装一个监视发送到消息队列的消息的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_JOURNALPLAYBACK&lt;/td&gt;&#xA;          &lt;td&gt;安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_JOURNALRECORD&lt;/td&gt;&#xA;          &lt;td&gt;安装一个挂钩过程，记录发布到系统消息队列的输入消息。这个钩子对于录制宏很有用。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_KEYBOARD&lt;/td&gt;&#xA;          &lt;td&gt;安装监视按键消息的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_KEYBOARD_LL&lt;/td&gt;&#xA;          &lt;td&gt;安装监视低级别键盘输入事件的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_MOUSE&lt;/td&gt;&#xA;          &lt;td&gt;安装监视鼠标消息的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_MOUSE_LL&lt;/td&gt;&#xA;          &lt;td&gt;安装监视低级别鼠标输入事件的挂钩过程。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_MSGFILTER&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，用于监视在对话框，消息框，菜单或滚动条中由于输入事件而生成的消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_SHELL&lt;/td&gt;&#xA;          &lt;td&gt;安装接收对shell应用程序有用的通知的挂钩程序。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;WH_SYSMSGFILTER&lt;/td&gt;&#xA;          &lt;td&gt;安装钩子程序，用于监视在对话框，消息框，菜单或滚动条中由于输入事件而生成的消息。钩子程序监视与调用线程相同的桌面中的所有应用程序的这些消息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;普通的钩子需要写在dll程序中才能执行,但是低级键盘钩子可以在无dll的情况下运行,比如低级键盘钩子和低级鼠标钩子,判断钩子的优先级遵循一个原则,后下的钩子先执行,WH_DEBUG&amp;gt;WH_KEYBOARD_LL&amp;gt;WH_KEYBOARD,即调试钩子&amp;gt;低级钩子&amp;gt;普通钩子&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows进程创建过程</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/windows%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/</guid>
      <description>&lt;h3 id=&#34;子系统类型选项&#34;&gt;子系统类型选项&lt;/h3&gt;&#xA;&lt;p&gt;当创建一个饮用程序的时候,连接器选项中有一个很重要的参数,就是子系统类型选择(/SUBSYSTEM:),其中比较常用的有CONSOLE,WINDOWS,NATIVE三个选项,对应CUI程序,GUI程序以及系统和驱动程序这三种.&#xA;当用户运行应用程序时,系统的PE loader会根据可选PE头中的信息来加载程序,如果是CUI程序,系统会保证至少有一个终端来显示程序运行的结果(举例来说就是如果从cmd中打开CUI程序,若不是命令指定在新窗口中打开,则只会在输入命令的终端窗口显示输出结果;而如果我们用任务管理器开启一个CUI程序,则系统会帮我们打开一个新终端来显示结果,至于为什么结果会一闪而过,这是因为你在编写程序时没加一些让它停下来的指令,程序运行完成就return 0么得了)&#xA;而如果这是一个GUI程序,系统就只会加载这个程序,不会给你加一个默认的界面,因为他认为你自己会设计一个图形化的界面的.&lt;/p&gt;&#xA;&lt;h3 id=&#34;main函数开始之前是什么&#34;&gt;main函数开始之前是什么&lt;/h3&gt;&#xA;&lt;p&gt;main函数是我们程序员写下的代码开始发挥作用的地方,但是程序运行时最先执行的函数并不是main函数,main函数之前操作系统会调用c/c++运行时启动函数比图mainCRTStartup这种东西,GUI程序则是WinMainCRTStartup函数.这个函数主要做哪些事情:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;获取完整命令行和环境变量&lt;/li&gt;&#xA;&lt;li&gt;初始化c/c++运行库的全局变量&lt;/li&gt;&#xA;&lt;li&gt;初始化内存分配函数,比如malloc和alloc函数以及其他底层IO例程需要用到的堆,始化以下指针变量：stdin,stdout,stderr.(限控制台程序)&lt;/li&gt;&#xA;&lt;li&gt;调用所有全局变量和静态c++类对象的构造函数&#xA;完成这些工作后会调用应用程序的入口点函数,同时定义变量nMainRetVal = main函数的返回值,之后程序的控制权便交给了main函数(或者WinMain函数),当main函数返回后(即return 0),会调用exit函数,进行以下过程:&lt;/li&gt;&#xA;&lt;li&gt;调用_onexit函数调用所注册的函数&lt;/li&gt;&#xA;&lt;li&gt;调用所有全局变量和静态c++类对象的析构函数&lt;/li&gt;&#xA;&lt;li&gt;释放堆及其他资源&lt;/li&gt;&#xA;&lt;li&gt;调用exit函数退出程序,向其传入的参数是main函数的返回值&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;不被注意但是天天见的explorer&#34;&gt;不被注意但是天天见的explorer&lt;/h3&gt;&#xA;&lt;p&gt;explorer进程掌管着进入系统后我们在桌面上看到的大部分东西:壁纸,快捷方式,桌面上基本一切的一切都是它产生的,如果你kill掉这个process,桌面就乌漆嘛黑啥也没了.我们双击图标能够创建进程,就是归功于explorer.exe的,这个程序会在你双击图标的时候调用CreateProcess函数创建进程.&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程是如何创建出来的&#34;&gt;进程是如何创建出来的&lt;/h3&gt;&#xA;&lt;p&gt;首先明确一点就是任何进程都是其他进程创建出来的,比如一般我们在桌面上双击图标就是让explorer创建了进程.&#xA;进程的创建过程:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;映射exe文件(简单说是把文件放到内存中,)&lt;/li&gt;&#xA;&lt;li&gt;创建内核对象EPROCESS&lt;/li&gt;&#xA;&lt;li&gt;映射系统DLL(ntdll.dll)&lt;/li&gt;&#xA;&lt;li&gt;创建线程内核对象ETHREAD&lt;/li&gt;&#xA;&lt;li&gt;系统创建线程&lt;/li&gt;&#xA;&lt;li&gt;映射dll(ntdll!LdrlnitializeThunk)&lt;/li&gt;&#xA;&lt;li&gt;线程开始执行&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;关键系统进程&#34;&gt;关键系统进程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;System Idle Process进程:pid为0,处理器有几个线程这玩意有几个线程,功能是循环统计CPU的空闲度,这个值越大越好。&lt;/li&gt;&#xA;&lt;li&gt;System进程：ID为4，包含了内核模式系统线程。系统辅助线程、执行体和驱动进程通过PsCreateSystemThread创建的线程都在System中。这个进程中的所有模块都处在高地址的内核内存区(即0x80000000后),受到保护.&lt;/li&gt;&#xA;&lt;li&gt;winlogon.exe：登录进程，负责用户交互的登录和注销。Ctrl+Alt+Del就是给它发请求。这就是为什么手贱结束explorer进程之后仍然可以Ctrl+Alt+Del打开任务管理器再次启动explorer进程来恢复正常.&lt;/li&gt;&#xA;&lt;li&gt;csrss.exe：Windows子系统环境进程，包括控制面板窗口的功能，创建删除进程和线程。&lt;/li&gt;&#xA;&lt;li&gt;lsass.exe：本地系统安全策略。负责允许哪些用户登录到本地系统、口令策略、授予用户和用户组的特权、系统安全审计设置、认证用户身份、安全审计消息发送到系统的Event Log等功能。&lt;/li&gt;&#xA;&lt;li&gt;services.exe：负责管理Windows系统服务，这里的系统服务指一些特殊的进程，通常不与登录用户进行交互，因而被配置成可以在系统引导时自启动，无需交互登录过程。Windows中很多功能组件都是以服务方式实现的，比如Event Log，任务调度器和各种网络组件等。&lt;/li&gt;&#xA;&lt;li&gt;smss.exe:这是Windows的核心进程之一，是Windows NT内核的会话管理程序。&lt;/li&gt;&#xA;&lt;li&gt;Svchost.exe:这属于Windows的系统程序，服务进程的执行离不开这个程序。开机出现“Generic host processfor win32 services”（遇到问题需要关闭），一般是这个进程找不到dll文件所致。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>windows 10下利用schtasks绕过uac</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/uac_bypass/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/uac_bypass/</guid>
      <description>&lt;h3 id=&#34;0x00-前言&#34;&gt;0x00 前言&lt;/h3&gt;&#xA;&lt;p&gt;最近在刷知乎的时候发现了一种早就被揭露但目前为止还未被修复的uac bypass手段，个人觉得其中的思路很有参考意义，故记录下来学习一下。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x01-原理&#34;&gt;0x01 原理&lt;/h3&gt;&#xA;&lt;p&gt;这种uac bypass的原理是寻找权限控制不严格的程序进行劫持，以达到绕过uac使用管理员权限的shell。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x02-利用方法&#34;&gt;0x02 利用方法&lt;/h3&gt;&#xA;&lt;p&gt;计划任务中的silentcleanup的关键信息如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-16&amp;#34;?&amp;gt;&#xA;&amp;lt;Task xmlns=&amp;#34;http://schemas.microsoft.com/windows/2004/02/mit/task&amp;#34;&amp;gt;&#xA;  &amp;lt;RegistrationInfo&amp;gt;&#xA;    &amp;lt;SecurityDescriptor&amp;gt;D:AI(A;;FA;;;BA)(A;;FA;;;SY)(A;;FRFX;;;AU)&amp;lt;/SecurityDescriptor&amp;gt;&#xA;    &amp;lt;Source&amp;gt;$(@%systemroot%\system32\cleanmgr.exe,-1300)&amp;lt;/Source&amp;gt;&#xA;    &amp;lt;Author&amp;gt;$(@%systemroot%\system32\cleanmgr.exe,-1300)&amp;lt;/Author&amp;gt;&#xA;    &amp;lt;Description&amp;gt;$(@%systemroot%\system32\cleanmgr.exe,-1301)&amp;lt;/Description&amp;gt;&#xA;    &amp;lt;URI&amp;gt;Microsoft\Windows\DiskCleanup\SilentCleanup&amp;lt;/URI&amp;gt;&#xA;  &amp;lt;/RegistrationInfo&amp;gt;&#xA;  &amp;lt;Principals&amp;gt;&#xA;    &amp;lt;Principal id=&amp;#34;Authenticated Users&amp;#34;&amp;gt;&#xA;      &amp;lt;GroupId&amp;gt;S-1-5-32-545&amp;lt;/GroupId&amp;gt;&#xA;      &amp;lt;RunLevel&amp;gt;HighestAvailable&amp;lt;/RunLevel&amp;gt;&#xA;    &amp;lt;/Principal&amp;gt;&#xA;  &amp;lt;/Principals&amp;gt;&#xA;  &amp;lt;Settings&amp;gt;&#xA;    &amp;lt;DisallowStartIfOnBatteries&amp;gt;true&amp;lt;/DisallowStartIfOnBatteries&amp;gt;&#xA;    &amp;lt;StopIfGoingOnBatteries&amp;gt;true&amp;lt;/StopIfGoingOnBatteries&amp;gt;&#xA;    &amp;lt;ExecutionTimeLimit&amp;gt;PT15M&amp;lt;/ExecutionTimeLimit&amp;gt;&#xA;    &amp;lt;MultipleInstancesPolicy&amp;gt;IgnoreNew&amp;lt;/MultipleInstancesPolicy&amp;gt;&#xA;    &amp;lt;StartWhenAvailable&amp;gt;true&amp;lt;/StartWhenAvailable&amp;gt;&#xA;    &amp;lt;RunOnlyIfIdle&amp;gt;true&amp;lt;/RunOnlyIfIdle&amp;gt;&#xA;    &amp;lt;IdleSettings&amp;gt;&#xA;      &amp;lt;StopOnIdleEnd&amp;gt;true&amp;lt;/StopOnIdleEnd&amp;gt;&#xA;      &amp;lt;RestartOnIdle&amp;gt;true&amp;lt;/RestartOnIdle&amp;gt;&#xA;    &amp;lt;/IdleSettings&amp;gt;&#xA;    &amp;lt;UseUnifiedSchedulingEngine&amp;gt;true&amp;lt;/UseUnifiedSchedulingEngine&amp;gt;&#xA;    &amp;lt;MaintenanceSettings&amp;gt;&#xA;      &amp;lt;Period&amp;gt;P1D&amp;lt;/Period&amp;gt;&#xA;      &amp;lt;Deadline&amp;gt;P1M&amp;lt;/Deadline&amp;gt;&#xA;    &amp;lt;/MaintenanceSettings&amp;gt;&#xA;  &amp;lt;/Settings&amp;gt;&#xA;  &amp;lt;Triggers /&amp;gt;&#xA;  &amp;lt;Actions Context=&amp;#34;Authenticated Users&amp;#34;&amp;gt;&#xA;    &amp;lt;Exec&amp;gt;&#xA;      &amp;lt;Command&amp;gt;%windir%\system32\cleanmgr.exe&amp;lt;/Command&amp;gt;&#xA;      &amp;lt;Arguments&amp;gt;/autoclean /d %systemdrive%&amp;lt;/Arguments&amp;gt;&#xA;    &amp;lt;/Exec&amp;gt;&#xA;  &amp;lt;/Actions&amp;gt;&#xA;&amp;lt;/Task&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到Authenticated Users表示普通用户权限即可启动而RunLevel为Highest表示以高权限启动。这就使得劫持该程序可以运行拥有管理员权限的shell进行操作。&#xA;打开SilentCleanup这一文件查看其中代码，可知它其实是运行了%windir%\system32\cleanmgr.exe /autoclean /d %systemdrive% 这一命令。我们只要将%windir%的环境变量进行修改即可实现对该程序的劫持。&#xA;比如说：将%windir%设置为C:\hack并在C:\hack\system32下将payload.exe保存为cleanmgr.exe那么在启动计划任务SilentCleanup时，就会以高权限运行代码.&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x03-具体代码实现&#34;&gt;0x03 具体代码实现&lt;/h3&gt;&#xA;&lt;p&gt;分为两种版本吧：&#xA;1.cmd版本&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows编程中的Unicode问题</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/windows%E5%AF%B9unicode%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/windows%E5%AF%B9unicode%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>&lt;h3 id=&#34;windows操作系统内核对unicode的支持&#34;&gt;Windows操作系统内核对Unicode的支持&lt;/h3&gt;&#xA;&lt;p&gt;Windows操作系统内核中的字符表示为UTF-16小尾序，可以正确处理、显示以4字节存储的字符。但是Windows API实际上仅能正确处理UCS-2字符，即仅以2字节存储的，码位小于U+FFFF的Unicode字符。其根源是Microsoft C++语言把wchar_t数据类型定义为16比特的unsigned short，这就与一个wchar_t型变量对应一个宽字符，可以存储一个Unicode字符的规定相矛盾。相反，Linux平台的GCC编译器规定一个wchar_t是4字节长度，可以存储一个UTF-32字符，宁可浪费了很大的存储空间。&lt;/p&gt;&#xA;&lt;h3 id=&#34;windows编程中l_t-text和_text的使用及其区别&#34;&gt;windows编程中L，_T() ，TEXT和_TEXT的使用及其区别&lt;/h3&gt;&#xA;&lt;p&gt;其实一句话概括的话,其实没有区别。字符串（literal string）前面的大写字母L，用来告诉编译器该字符串应该作为Unicode来编译。它用来将ASNI转换为Unicode。&#xA;tchar.h中定义如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  1. #define _T(x)       __T(x)  &#xA;  2. #define _TEXT(x)    __T(x)  &#xA;  3.   &#xA;  4. #ifdef  _UNICODE  &#xA;  5. #define __T(x)      L ## x     &#xA;  6. #else  &#xA;  7. #define __T(x)      x         &#xA;  8. #endif  &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;winnt.h中定义如下:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  1. #define TEXT(quote) __TEXT(quote)   &#xA;  2.   &#xA;  3. #ifdef  UNICODE                       &#xA;  4. #define __TEXT(quote) L##quote        &#xA;  5. #else   /* UNICODE */                 &#xA;  6. #define __TEXT(quote) quote           &#xA;  7. #endif /* UNICODE */  &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到tchar.h是运行时的头文件，_T、_TEXT 根据_UNICODE来确定宏&#xA;winnt.h是Win的头文件根据，TEXT 根据UNICODE 来确定宏&lt;/p&gt;&#xA;&lt;p&gt;如果需要同时使用这3个宏，则需同时定义 UNICODE 和 _UNICODE_&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python编码问题</title>
      <link>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/%E4%BB%8Emsvcrt%E5%88%B0python%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/windows%E6%9C%BA%E5%88%B6/%E4%BB%8Emsvcrt%E5%88%B0python%E7%BC%96%E7%A0%81/</guid>
      <description>&lt;h3 id=&#34;起因&#34;&gt;起因&lt;/h3&gt;&#xA;&lt;p&gt;估计正常人很难想到这两者之间的关系,又是折腾的一天,我对mingw-w64的编译器如何链接msvcrt.dll文件产生一些疑问,在看Windows网络编程的时候,开头要加上一句命令:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;#pragma comment(lib,&amp;ldquo;WS2_32&amp;rdquo;)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;通过这条命令来链接dll库,那么编译器是如何链接msvcrt.dll的,翻找了一些头文件,并未看到有相关的语句,一个个找又太麻烦,还是让脚本来帮我找一下吧,python撸一个脚本.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os&#xA;path = &amp;#34;D:\\mingw\\mingw64\\x86_64-w64-mingw32\\include&amp;#34; #文件夹目录&#xA;files= os.listdir(path) &#xA;s = []&#xA;for file in files: #遍历文件夹&#xA;     if os.path.isfile(path+&amp;#34;\\&amp;#34;+file): &#xA;          f = open(path+&amp;#34;\\&amp;#34;+file,&amp;#39;r&amp;#39;) #打开文件&#xA;          str_f = f.readlines() &#xA;          str = &amp;#34;#pragma comment&amp;#34;&#xA;          if str in str_f:&#xA;               s.append(file) &#xA;print(s) #打印结果&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后顺利发生异常,UnicodeDecodeError:&amp;lsquo;gbk&amp;rsquo; codec can&amp;rsquo;t decode byte 0x99 in position 2613: illegal multibyte sequence&lt;/p&gt;&#xA;&lt;h3 id=&#34;python编码问题&#34;&gt;python编码问题&lt;/h3&gt;&#xA;&lt;h4 id=&#34;一些基本概念&#34;&gt;一些基本概念&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编码：将人类可识别的字符转换为机器可识别的字节码 / 字节序列&lt;/li&gt;&#xA;&lt;li&gt;解码：编码的反向过程叫解码&lt;/li&gt;&#xA;&lt;li&gt;字符集: 某个范围内字符的集合，不同的字符集规定了字符的个数，比如 ASCII 字符集总共有128个字符，包含了英文字母、阿拉伯数字、标点符号和控制符。而 GB2312 字符集定义了7445个字符，包含了绝大部分汉字字符。&lt;/li&gt;&#xA;&lt;li&gt;字符是以字节为存储单位保存在文件中，文件保存在内存 / 物理磁盘中&lt;/li&gt;&#xA;&lt;li&gt;编码和解码: 编码的过程是将字符转换成字节流，解码的过程是将字节流解析为字符。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;编码问题的解决&#34;&gt;编码问题的解决&lt;/h4&gt;&#xA;&lt;p&gt;python中使用open()函数,默认的解码方式取决于平台,在Windows平台下是gbk,如图&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
