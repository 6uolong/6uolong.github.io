<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>安卓逆向 on huolong blog</title>
    <link>http://localhost:1313/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/</link>
    <description>Recent content in 安卓逆向 on huolong blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Oct 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Root检测</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/root%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Mon, 03 Oct 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/root%E6%A3%80%E6%B5%8B/</guid>
      <description>&lt;h3 id=&#34;执行su指令查看结果&#34;&gt;执行su指令查看结果&lt;/h3&gt;&#xA;&lt;p&gt;安装Magisk后在/system/bin目录下会多一个可执行文件magisk和两个指向它的符号链接su和setprop，因此我们可以通过执行su指令来判断Magisk是否安装，或者通过执行which命令查看是否存在su路径，进而确定设备是否root，检测代码如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FILE *fp = nullptr;&#xA;char cmd[65536];&#xA;sprintf(cmd, &amp;#34;su 2&amp;gt;&amp;amp;1&amp;#34;); // 或者使用which su来确定&#xA;if ((fp = popen(cmd, &amp;#34;r&amp;#34;)) != nullptr)&#xA;{&#xA;    fread(cmd, 1, sizeof(cmd), fp);&#xA;    pclose(fp);&#xA;}&#xA;alog(4,&amp;#34;native&amp;#34;, &amp;#34;result: %s&amp;#34;, cmd);&#xA;if(strstr(cmd,&amp;#34;inaccessible or not found&amp;#34;) != nullptr) // 相应改成是否有输出进行判断&#xA;    return env-&amp;gt;NewStringUTF(&amp;#34;not rooted&amp;#34;);&#xA;return env-&amp;gt;NewStringUTF(&amp;#34;rooted&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用mount命令查看命名空间&#34;&gt;使用mount命令查看命名空间&lt;/h3&gt;&#xA;&lt;p&gt;magisk会使用.magisk命名空间挂载许多文件，故使用mount命令即可查看手机是否被root，检测代码如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FILE *fp = nullptr;&#xA;char cmd[65536];&#xA;sprintf(cmd, &amp;#34;mount 2&amp;gt;&amp;amp;1&amp;#34;);&#xA;if ((fp = popen(cmd, &amp;#34;r&amp;#34;)) != nullptr)&#xA;{&#xA;    fread(cmd, 1, sizeof(cmd), fp);&#xA;    pclose(fp);&#xA;}&#xA;alog(4,&amp;#34;native&amp;#34;, &amp;#34;result: %s&amp;#34;, cmd);&#xA;if(strstr(cmd,&amp;#34;magisk&amp;#34;) == nullptr) \\运行结果不含magisk则未root&#xA;    return env-&amp;gt;NewStringUTF(&amp;#34;not rooted&amp;#34;);&#xA;return env-&amp;gt;NewStringUTF(&amp;#34;rooted&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>Frida踩坑笔记</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/frida%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/frida%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;慎用js箭头函数&#34;&gt;慎用Js箭头函数&lt;/h3&gt;&#xA;&lt;p&gt;前段时间在逆向app时候需要hook onCreate函数，需要调用父类的onCreate的方法进行初始化，此时修改函数内部逻辑时候碰到了两个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;父类的super函数如何获取&lt;/li&gt;&#xA;&lt;li&gt;使用箭头函数时候this为null&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;需要注意调用父类函数正确写法为：this.$super&#xA;此外以下使用箭头函数hook的写法是错误的，此时获取的this值为null&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Java.use(&amp;#34;com.hex.wanshiwu.v2.splash.SplashActivityV2&amp;#34;)&#xA;            .onCreate.implementation = (bundle)=&amp;gt;{&#xA;                this.$super.onCreate(bundle)&#xA;                let intent = Java.use(&amp;#34;android.content.Intent&amp;#34;)&#xA;                .$new(this,Java.use(&amp;#34;com.hex.wanshiwu.v2.main.MainActivityV2&amp;#34;).class)&#xA;                this.startActivity(intent)&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正确写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Java.use(&amp;#34;com.hex.wanshiwu.v2.splash.SplashActivityV2&amp;#34;)&#xA;            .onCreate.implementation = function(bundle){&#xA;                this.$super.onCreate(bundle)&#xA;                let intent = Java.use(&amp;#34;android.content.Intent&amp;#34;)&#xA;                .$new(this,Java.use(&amp;#34;com.hex.wanshiwu.v2.main.MainActivityV2&amp;#34;).class)&#xA;                this.startActivity(intent)&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>LLVM框架开发（二）</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%BA%8C/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%BA%8C/</guid>
      <description>&lt;h3 id=&#34;指令替换pass编写&#34;&gt;指令替换pass编写&lt;/h3&gt;&#xA;&lt;p&gt;上一节介绍了如何使用新旧PassManager进行Pass编写，本节则真正上手一个Pass的编写过程中去。&#xA;该Pass的主要目标是将加减乘除等简单运算替换为更复杂但效果等价的操作，提高逆向分析的难度。以下代码将运算a+b替换为：a-(-b)&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void subAddInst(Function &amp;amp;f)&#xA;{&#xA;    Function *tmp = &amp;amp;f;&#xA;    BinaryOperator *work = nullptr;&#xA;    // 遍历函数中的基本块&#xA;    for (Function::iterator bb = tmp-&amp;gt;begin(); bb != tmp-&amp;gt;end(); ++bb)&#xA;    {&#xA;        // 遍历基本块中的命令&#xA;        for (BasicBlock::iterator ins = bb-&amp;gt;begin(); ins != bb-&amp;gt;end(); ++ins)&#xA;        {&#xA;            if (ins-&amp;gt;isBinaryOp())&#xA;            {&#xA;                if (ins-&amp;gt;getOpcode() == Instruction::Add)&#xA;                {&#xA;                    errs() &amp;lt;&amp;lt; &amp;#34;find add op&amp;#34; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;&#xA;                    BinaryOperator *op = dyn_cast&amp;lt;BinaryOperator&amp;gt;(ins);&#xA;                    IRBuilder&amp;lt;&amp;gt; builder(op);&#xA;                    Value *negInst = builder.CreateNeg(op-&amp;gt;getOperand(1));&#xA;                    Value *newInst = builder.CreateSub(op-&amp;gt;getOperand(0), negInst);&#xA;                    op-&amp;gt;replaceAllUsesWith(newInst);&#xA;                    work = op;&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    // 注意原命令脱离基本块操作不要在迭代中实现，否则会破坏迭代结构进而报错&#xA;    work-&amp;gt;eraseFromParent();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;函数空壳化pass编写&#34;&gt;函数空壳化pass编写&lt;/h3&gt;&#xA;&lt;p&gt;恶作剧形式的一个Pass，功能为将传入的函数除了return命令以外的所有命令移除，达到该函数没有功能的作用（目前只对main函数起作用）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Xposed模块入门</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/xposed%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/xposed%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h3 id=&#34;编辑mainfest文件&#34;&gt;编辑Mainfest文件&lt;/h3&gt;&#xA;&lt;p&gt;在AndroidMainfest文件中Application项中加入以下数据&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;meta-data&#xA;android:name=&amp;#34;xposedmodule&amp;#34;&#xA;android:value=&amp;#34;true&amp;#34; /&amp;gt;&#xA;&#xA;&amp;lt;meta-data&#xA;android:name=&amp;#34;xposeddescription&amp;#34;&#xA;android:value=&amp;#34;xposed模块描述&amp;#34; /&amp;gt;&#xA;&#xA;&amp;lt;meta-data&#xA;android:name=&amp;#34;xposedminversion&amp;#34;&#xA;android:value=&amp;#34;82&amp;#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;插入以上数据的目的是使得Xposed框架能够知道这个apk是一个模块文件&lt;/p&gt;&#xA;&lt;h3 id=&#34;加载jar包&#34;&gt;加载jar包&lt;/h3&gt;&#xA;&lt;p&gt;1.手动添加：将jar下载到本地后自行添加。手动下载XposedBridgeApi-82.jar文件，拖放到“项目名称/app/libs/”，然后右键“Add As Library” 自行添加这个jar包。之后在build.gradle的dependencies目录下添加命令&#xA;&lt;code&gt;compileOnly files(&#39;libs\\api-82.jar&#39;)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;2.自动同步：如果网络情况允许的话，可以直接在gradle文件下的dependencies下添加：&lt;code&gt;compileOnly &#39;de.robv.android.xposed:api:82&#39;&lt;/code&gt;，这样可以免去事先下载jar包的步骤，需要注意的是随着jcenter仓库关闭，目前直接使用该配置gradle会报错，所以需要在settings.gradle配置文件中做如下配置：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;config.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;添加入口点&#34;&gt;添加入口点&lt;/h3&gt;&#xA;&lt;p&gt;没有添加入口点的xposed模块可以被xposed管理器识别，但是不可以启用，必须指明入口点，启用的方法也很简单：&lt;/p&gt;&#xA;&lt;p&gt;在\src\main目录下创建assets文件夹，在该文件夹下创建入口点文件xposed_init，内容为编写的Hook类类名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;编写主要类文件&#34;&gt;编写主要类文件&lt;/h3&gt;&#xA;&lt;p&gt;这是hook类代码的一个实例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.huol.sswcrack;&#xA;&#xA;import android.app.Activity;&#xA;import android.content.Intent;&#xA;import android.os.Bundle;&#xA;&#xA;import de.robv.android.xposed.IXposedHookLoadPackage;&#xA;import de.robv.android.xposed.XC_MethodHook;&#xA;import de.robv.android.xposed.XposedBridge;&#xA;import de.robv.android.xposed.XposedHelpers;&#xA;import de.robv.android.xposed.callbacks.XC_LoadPackage;&#xA;&#xA;public class Crack implements IXposedHookLoadPackage {&#xA;    public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {&#xA;        if (lpparam.packageName.equals(&amp;#34;com.qq.ssw1&amp;#34;)) {&#xA;            ClassLoader classLoader = lpparam.classLoader;&#xA;            XposedBridge.log(&amp;#34;Loaded app: &amp;#34; + lpparam.packageName);&#xA;            Class clazz = XposedHelpers.findClass(&amp;#34;com.qq.ssw.v2.splash.SplashActivityV2&amp;#34;, lpparam.classLoader);&#xA;            XposedHelpers.findAndHookMethod(clazz, &amp;#34;onCreate&amp;#34;, Bundle.class, new XC_MethodHook() {&#xA;                @Override&#xA;                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {&#xA;                    super.beforeHookedMethod(param);&#xA;                    Class mainActivity = XposedHelpers.findClass(&amp;#34;com.qq.ssw.v2.main.MainActivityV2&amp;#34;, lpparam.classLoader);&#xA;                    Activity activity = (Activity) param.thisObject;&#xA;                    Intent mIntent = new Intent(activity, mainActivity);&#xA;                    activity.startActivity(mIntent);&#xA;                }&#xA;            }); // 去开屏广告和不必要权限要求&#xA;            XposedHelpers.findAndHookMethod(&amp;#34;tencent.io.b&amp;#34;, classLoader, &amp;#34;i&amp;#34;, new XC_MethodHook() {&#xA;                @Override&#xA;                protected void afterHookedMethod(MethodHookParam param) throws Throwable {&#xA;                    super.afterHookedMethod(param);&#xA;                    param.setResult(true);&#xA;                }&#xA;            }); //破解会员&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Android逆向环境配置</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/android%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/android%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;h3 id=&#34;手机root权限获取&#34;&gt;手机Root权限获取&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;解锁BootLoader，此处推荐小米、一加等比较容易解锁的手机，小米需要等14天才能解锁，一加到手就能解锁，且这两个牌子解锁后仍然保修。&lt;/li&gt;&#xA;&lt;li&gt;根据手机型号下载TWRP，使用fastboot刷入。&lt;/li&gt;&#xA;&lt;li&gt;到 &lt;a href=&#34;https://github.com/topjohnwu/Magisk&#34;&gt;https://github.com/topjohnwu/Magisk&lt;/a&gt; 下载Magisk框架，修改后缀为.zip文件&lt;/li&gt;&#xA;&lt;li&gt;进入Recovery，可以看到此时已经被替换为TWRP，刷入类原生ROM（比较知名的有PE、crdroid、Dotos等等，注意型号）或者AOSP，这样做是为了减少出厂系统的深度魔改造成一些难以解决的错误。&lt;/li&gt;&#xA;&lt;li&gt;找到Magisk的zip文件，刷入Magisk框架，此时便获得了Root权限&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;更加详细的教程参见 &lt;a href=&#34;https://www.bilibili.com/video/BV1BY4y1H7Mc&#34;&gt;https://www.bilibili.com/video/BV1BY4y1H7Mc&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;rodebuggable属性修改&#34;&gt;ro.debuggable属性修改&lt;/h3&gt;&#xA;&lt;p&gt;通过magisk修改（重启失效），连接电脑输入以下指令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;adb shell&#xA;su&#xA;magisk resetprop ro.debuggable 1&#xA;stop;start;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除此之外还可以使用MagiskHide Props Config模块，安装后在adb shell中输入props，按照提示将ro.debuggable改为1即可，该方法修改后即使手机重启也不会失效。&lt;/p&gt;&#xA;&lt;p&gt;通过这样的配置之后Jadx，jeb等软件就可以动态调试手机上的软件了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;lsposed框架安装&#34;&gt;lsposed框架安装&lt;/h3&gt;&#xA;&lt;p&gt;Xposed框架在很早以前就已经停止更新，目前仍然维护的Xposed实现是lsposed框架，安装过程很简单，访问 &lt;a href=&#34;https://github.com/LSPosed/LSPosed&#34;&gt;https://github.com/LSPosed/LSPosed&lt;/a&gt; 下载zip包，在magisk管理器中安装即可（可以选择riru版或者zygisk版，建议安装zygisk版本，riru已经停更，预计不久riru版本的lsposed也会停更），需要注意的是zygisk版本的lsposed框架需要打开magisk的zygisk功能支持才能正常运行，注意在magisk设置中打开。&lt;/p&gt;&#xA;&lt;p&gt;安装成功后显示如下：&#xA;&lt;img src=&#34;lsp_success.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;frida环境安装&#34;&gt;frida环境安装&lt;/h3&gt;&#xA;&lt;p&gt;这是我们分析Java层代码的主力军之一，配合Jadx等静态分析工具能够做到快速定位目标功能代码，安装和配置步骤如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先在电脑上安装Python，推荐3.8.x版本，这是目前frida支持的最新版本，之后安装frida库和frida-tools库。命令如下：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install frida&#xA;pip install frida-tools&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;在已经安装magisk的手机上安装frida是很简单的一件事，访问 &lt;a href=&#34;https://github.com/ViRb3/magisk-frida/releases&#34;&gt;https://github.com/ViRb3/magisk-frida/releases&lt;/a&gt; 获取Magiskfrida模块，在Magisk管理器中安装即可。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;测试是否安装成功只需首先将手机通过USB连接到电脑上，注意允许USB调试，之后在电脑上打开终端输入命令&lt;code&gt;frida-ps -U&lt;/code&gt;，输出结果如下即为成功：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;frida_success.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在安装frida成功的基础上，安装objection库，该库是一个基于frida的扩展，提供了无代码hook，内存漫游和主动调用等等功能，安装只需一行命令：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;pip install objection&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;另外objection还有一些扩展插件可以按需安装：&#xA;wallbreaker &lt;a href=&#34;https://github.com/hluwa/Wallbreaker&#34;&gt;https://github.com/hluwa/Wallbreaker&lt;/a&gt; 能够快捷的列出内存中的对象的字段属性，方法等等。&#xA;Frida-Dexdump &lt;a href=&#34;https://github.com/hluwa/FRIDA-DEXDump&#34;&gt;https://github.com/hluwa/FRIDA-DEXDump&lt;/a&gt; 抓取内存中的dex文件达到快速脱壳的功能。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;apktool安装&#34;&gt;apktool安装&lt;/h3&gt;&#xA;&lt;p&gt;利用apktool能够便捷解码Android apk压缩包，使我们能够修改dex，Manifest，xml等等文件并重打包。&#xA;官方网站说的很详细，安装地址如下： &lt;a href=&#34;https://ibotpeaches.github.io/Apktool/install/&#34;&gt;https://ibotpeaches.github.io/Apktool/install/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;利用apktool重打包后需要配置密钥进行应用签名，签名步骤如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先生成签名，进入JDK/bin, 输入命令 &lt;code&gt;keytool -genkeypair -keystore 密钥库名 -alias 密钥别名 -validity 天数 -keyalg RSA &lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;进入目录Android SDK/build-tools/SDK版本/zipalign.exe，使用zipalign令APK包内未压缩的数据有序排列对齐，命令如下：&lt;code&gt;zipalign -p -f -v 4 infile.apk outfile.apk&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;进入Android SDK/build-tools/SDK版本目录下，输入命令&lt;code&gt;apksigner sign --ks 密钥库名 --ks-key-alias 密钥别名 xxx.apk&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;进行应用签名后，该重打包后的应用便可以在手机上安装运行了，不过建议现在大部分apk都有各种的重打包检测（主要是用签名信息做文章），apk的持久化修改还是使用lsposed框架省事点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LLVM框架开发（一）</title>
      <link>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%B8%80/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/llvm%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%B8%80/</guid>
      <description>&lt;h3 id=&#34;linux下llvm环境配置&#34;&gt;Linux下LLVM环境配置&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在Ubuntu和Debian环境下，直接使用官方脚本安装，输入下面的命令直接安装LLVM14&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://apt.llvm.org/llvm.sh&#xA;chmod +x llvm.sh&#xA;sudo ./llvm.sh 14&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意安装成功后命令会带上版本号，比如命令行下输入clang会提示找不到，但是输入clang-14就可以使用。&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;使用包管理器进行安装（推荐）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install clang&#xA;sudo apt install llvm&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这种方式安装的llvm和clang输入命令时不需要加版本号即可使用，推荐使用这种方法。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从源码编译安装&#xA;暂时还没用到这种方法，按下不表。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;使用旧passmanager开发第一个pass开发&#34;&gt;使用旧PassManager开发第一个Pass开发&lt;/h3&gt;&#xA;&lt;p&gt;参考官方经典案例Hello Pass：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;llvm/Pass.h&amp;#34;&#xA;#include &amp;#34;llvm/IR/Function.h&amp;#34;&#xA;#include &amp;#34;llvm/Support/raw_ostream.h&amp;#34;&#xA;#include &amp;#34;llvm/IR/LegacyPassManager.h&amp;#34;&#xA;#include &amp;#34;llvm/Transforms/IPO/PassManagerBuilder.h&amp;#34;&#xA;&#xA;using namespace llvm;&#xA;&#xA;namespace {&#xA;  struct Hello : public FunctionPass {&#xA;    static char ID;&#xA;    Hello() : FunctionPass(ID) {}&#xA;    bool runOnFunction(Function &amp;amp;F) override {&#xA;      errs() &amp;lt;&amp;lt; &amp;#34;Hello: &amp;#34;;&#xA;      errs().write_escaped(F.getName()) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;&#xA;      return false;&#xA;    }&#xA;  };&#xA;}&#xA;&#xA;char Hello::ID = 0;&#xA;&#xA;// Register for opt&#xA;static RegisterPass&amp;lt;Hello&amp;gt; X(&amp;#34;hello&amp;#34;, &amp;#34;Hello World Pass&amp;#34;);&#xA;&#xA;// Register for clang&#xA;static RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,&#xA;  [](const PassManagerBuilder &amp;amp;Builder, legacy::PassManagerBase &amp;amp;PM) {&#xA;    PM.add(new Hello());&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果出现include文件找不到错误，请在.bashrc文件中指明LLVM头文件的路径，命令如下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
