<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C和CPP on huolong blog</title>
    <link>https://6uolong.github.io/categories/c%E5%92%8Ccpp/</link>
    <description>Recent content in C和CPP on huolong blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 10 Sep 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://6uolong.github.io/categories/c%E5%92%8Ccpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;中的重写、隐藏与重载的区别</title>
      <link>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c&#43;&#43;%E4%B8%AD%E7%9A%84%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c&#43;&#43;%E4%B8%AD%E7%9A%84%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F%E9%87%8D%E8%BD%BD/</guid>
      <description>&lt;h3 id=&#34;c面向对象的一些易混淆概念&#34;&gt;C++面向对象的一些易混淆概念&lt;/h3&gt;&#xA;&lt;p&gt;重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。&lt;/p&gt;&#xA;&lt;p&gt;隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数且没有被virtual关键字修饰，不管参数列表是否相同，基类函数都会被隐藏。&lt;/p&gt;&#xA;&lt;p&gt;重载：是指同一类中内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。&#xA;注:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重写和被重写的函数在不同的类中，隐藏函数和被隐藏函数在不同类中,重载和被重载的函数在同一类中.&lt;/li&gt;&#xA;&lt;li&gt;重写与被重写的函数参数列表一定相同且必须有virtual修饰，重载和被重载的函数参数列表一定不同。&lt;/li&gt;&#xA;&lt;li&gt;当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;class base&#xA;{&#xA;public:&#xA;&#x9;int x;&#xA;public:&#xA;&#x9;base()&#xA;&#x9;{&#xA;&#x9;&#x9;x = 100;&#xA;&#x9;}&#xA;&#x9;void func1()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;base::func1调用&amp;#34;&amp;lt;&amp;lt;endl;&#xA;&#x9;}&#xA;&#x9;virtual void func2()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;base::func2调用&amp;#34; &amp;lt;&amp;lt; endl;&#xA;&#x9;}&#xA;};&#xA;class sub : public base&#xA;{&#xA;public:&#xA;&#x9;int x;&#xA;public:&#xA;&#x9;sub()&#xA;&#x9;{&#xA;&#x9;&#x9;x = 200;&#xA;&#x9;}&#xA;&#x9;void func1()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;sub::func1调用&amp;#34; &amp;lt;&amp;lt; endl;&#xA;&#x9;}&#xA;&#x9;virtual void func2()&#xA;&#x9;{&#xA;&#x9;&#x9;cout &amp;lt;&amp;lt; &amp;#34;sub::func2调用&amp;#34; &amp;lt;&amp;lt; endl;&#xA;&#x9;}&#xA;};&#xA;&#xA;int main(int argc, char** argv)&#xA;{&#xA;&#x9;sub b;&#xA;&#x9;base * p1=&amp;amp;b;&#xA;&#x9;p1-&amp;gt;func1();&#xA;&#x9;p1-&amp;gt;func2();&#xA;&#x9;cout &amp;lt;&amp;lt; p1-&amp;gt;x &amp;lt;&amp;lt; endl;&#xA;&#x9;sub* p2 = &amp;amp;b;&#xA;&#x9;p2-&amp;gt;func1();&#xA;&#x9;p2-&amp;gt;func2();&#xA;&#x9;cout &amp;lt;&amp;lt; p2-&amp;gt;x &amp;lt;&amp;lt; endl;&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果:&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;踩坑笔记</title>
      <link>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c&#43;&#43;%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c&#43;&#43;%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;vector中不能存放引用&#34;&gt;vector中不能存放引用&lt;/h3&gt;&#xA;&lt;p&gt;《C++ primer》中说过vector是不能存放引用的，原因是引用不支持一般意义上的赋值操作，而 vector中元素的两个要求是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;元素必须能赋值。&lt;/li&gt;&#xA;&lt;li&gt;元素必须能复制。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;对引用赋值会使得引用指向的对象被修改，而不是引用本身被修改。&#xA;同理在标准库提供的容器中的array、list等都不可以将引用作为容器元素，如果必须要实现类似的效果，可以将指针作为容器元素。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C语言零碎</title>
      <link>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E/</guid>
      <description>&lt;h3 id=&#34;c-语言中的输入输出&#34;&gt;C 语言中的输入输出&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;gets()函数和puts()函数一起处理字符串非常方便，gets()函数会自动将最后的回车“干掉”，这样就不用担心下次输入时发现缓冲区里面有个\n了。而puts()则会自动换行，配合使用very nice！&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;for(int i=0;i&amp;lt;N;i++)&lt;/code&gt;在for中定义的i变量也只在for的作用域中生效，如果i只是为了让{}中语句重复执行几次而没有什么特殊意义，这样写是可以的。&lt;/li&gt;&#xA;&lt;li&gt;可能令人吃惊，\n在scanf格式串中不表示等待换行符，而是读取并放弃连续的空白字符。（事实上，scanf格式串中的任何空白字符都表示读取并放弃空白字符。而且，诸如%d这样的格式也会扔掉前边的空白，因此你通常根本不需要在scanf格式串中加入显式的空白。）scanf()函数有些大坑，有些非常规输入你要懂得一些缓冲区的知识才能解释，因此如果你有拿这个玩意实现一些非常规操作的话，最好掂量一下。&lt;/li&gt;&#xA;&lt;li&gt;fgets()函数和gets()函数很像，别指望这个函数读取\n，它和gets一个尿性，无非是把stdin改成了任意FILE指针指向的地址，不过虽然不能读取\n，读取空格还是可以的。fgets(string,n,stdin)与gets(string)在一定范围内是等价的。&lt;/li&gt;&#xA;&lt;li&gt;stdin,stdout,stderr就是FILE类型的指针，不过他是随着计算机系统的开启默认打开的，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。printf（）其实就是向stdout中输出，等同于fprintf（stdout，&amp;ldquo;xxxx&amp;rdquo;），perror()其实就是向stderr中输出，相当于fprintf（stderr，&amp;ldquo;xxxx&amp;rdquo;）&lt;/li&gt;&#xA;&lt;li&gt;关于缓冲区的理解：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全缓冲&#xA;内存中有一段存储区域，比如有1024个字节大小，有一个程序会从这段存储区域中读取数据。现在系统把一个文件的内容放入这个存储区，只要1024个字节都放满了，那么程序会立即来读取这1024个字节的数据。只要1024个字节没有放满，哪怕只放了1023个字节，程序都不会来读取，这就是全缓冲的意思。&lt;/li&gt;&#xA;&lt;li&gt;行缓冲&#xA;内存中有一段存储区域，比如有1024个字节大小，有一个程序会从这段存储区域中读取数据。现在系统把一个文件的内容放入这个存储区，假如放了10个字节的数据，你敲了回车键，那么程序就马上来读取了。假如放了20个字节，你敲了回车键，程序也会来读取。所以即使1024个字节没有放满，但是你敲了回车键，程序就会来读取，这个就叫做行缓冲。典型代表是标准输入(stdin)和标准输出(stdout)，scanf()的诸多坑就是因为它的存在导致。&lt;/li&gt;&#xA;&lt;li&gt;无缓冲&#xA;内存中有一段存储区域，比如有1024个字节大小，有一个程序会从这段存储区域中读取数据。现在系统把一个文件的内容放入这个存储区，刚放了1个字节，程序就马上来读取了；又放了一个字节，程序又马上来读取了，这就是没有缓冲。比如getch()函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;linux与Windows上通用的清除缓冲区的方法，我们知道在Windows下清除缓冲区的方法是fflush(stdin)，但是该方法在linux下不一定能够奏效，我们可以使用scanf(&amp;quot;%*[^\n]%&lt;em&gt;c&amp;quot;);%&lt;/em&gt;[^\n]将逐个读取缓冲区中的 &amp;lsquo;\n&amp;rsquo; 字符之前的其它字符，% 后面的 * 表示将读取的这些字符丢弃，遇到 &amp;lsquo;\n&amp;rsquo; 字符时便停止读取。此时，缓冲区中尚有一个 &amp;lsquo;\n&amp;rsquo; 字符遗留，所以后面的%*c 将读取并丢弃这个遗留的换行符，这里的星号和前面的星号作用相同。由于所有从键盘的输入都是以回车结束的，而回车会产生一个 &amp;lsquo;\n&amp;rsquo; 字符，所以将 &amp;lsquo;\n&amp;rsquo; 连同它之前的字符全部读取并丢弃之后，也就相当于清除了输入缓冲区。&lt;/li&gt;&#xA;&lt;li&gt;C语言数组的初始化：C语言会在初始化数组的时候把未赋值的元素赋值为0，注意在对字符串进行初始化的时候不要让字符串长度正好等于元素个数，否则在输出的时候可能发生错误(原因：&amp;rsquo;\0&amp;rsquo;为字符串结束的标志，因为长度和元素个数正好相等，结尾没有&amp;rsquo;\0&amp;rsquo;，系统不知道什么时候字符串结束，可能会多输出)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;格式化输出&#34;&gt;格式化输出&lt;/h3&gt;&#xA;&lt;p&gt;%n存在的内存泄漏和修改漏洞&#xA;%n可以再printf函数中对变量赋值,值的大小为printf执行到%n处打印的字符数目&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;&#xA;int main()&#xA;{&#xA;&#x9;char* p = &amp;#34;hello,world&amp;#34;;&#xA;&#x9;int len = 0;&#xA;&#x9;printf(&amp;#34;helloworld%n&amp;#34;,&amp;amp;len);&#xA;&#x9;printf(&amp;#34;%d&amp;#34;, len);&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为它能够修改内存,故从很早之前开始在VS编程中使用%n会导致程序无法运行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结构体所占内存问题&#34;&gt;结构体所占内存问题&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;&#xA;typedef struct &#xA;{&#xA;&#x9;char c1;&#xA;&#x9;long i;&#xA;&#x9;char c2;&#xA;&#x9;double f;&#xA;}a;&#xA;typedef struct&#xA;{&#xA;&#x9;char c1;&#xA;&#x9;char c2;&#xA;&#x9;long i;&#xA;&#x9;double f;&#xA;}b;&#xA;int main()&#xA;{&#xA;&#x9;printf(&amp;#34;%d %d&amp;#34;, sizeof(a),sizeof(b));&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果猜猜是什么? 24和16&#xA;结构体所占大小的两条准则:&lt;/p&gt;</description>
    </item>
    <item>
      <title>C语言预处理机制</title>
      <link>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/c%E5%92%8Ccpp/c%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h3 id=&#34;宏定义&#34;&gt;宏定义&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无参数宏定义&#xA;#define PI 3.1415926&#xA;#define _WINDOWS_&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要注意的是宏只是简单的替换,宏常量没有数据类型,编译器不会对此进行检查,可能产生意想不到的错误.如果要定义常量,最好使用const定义常量.&lt;/li&gt;&#xA;&lt;li&gt;宏定义末尾不必加分号，否则连分号一并替换.&lt;/li&gt;&#xA;&lt;li&gt;预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;带参宏定义&#xA;#define MAX(x, y)     (((x) &amp;gt; (y)) ? (x) : (y))&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;宏定义时建议所有的层次都要加括号,因为预处理只是把宏展开,不加括号可能造成意想不到的后果.比如数值计算出错.&lt;/li&gt;&#xA;&lt;li&gt;带参数的宏定义可以部分替代函数的功能,相比函数的好处是用宏只会增加编译时间,不会增加内存的分配.而函数则会在栈上分配空间,占用内存.&lt;/li&gt;&#xA;&lt;li&gt;#define可以定义多条语句，以替代多行的代码，但应注意替换后的形式，避免出错。宏定义在换行时要加上一个反斜杠”\”，而且反斜杠后面直接回车，不能有空格。例子:&#xA;#define TMAX_S(type, x, y) ({ &lt;br&gt;&#xA;type _x = (x);  &lt;br&gt;&#xA;type _y = (y);  &lt;br&gt;&#xA;_x &amp;gt; _y ? _x: _y; })&#xA;这是安全版的max函数.&#xA;Gcc编译器将包含在圆括号和大括号双层括号内的复合语句看作是一个表达式，它可出现在任何允许表达式的地方；复合语句中可声明局部变量，判断循环条件等复杂处理。而表达式的最后一条语句必须是一个表达式，它的计算结果作为返回值。这样部分替代了函数的功能.&lt;/li&gt;&#xA;&lt;li&gt;取消宏定义可用#undef命令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;字符串化操作符&#34;&gt;字符串化操作符#&lt;/h3&gt;&#xA;&lt;p&gt;下面开始就是我们在课堂上没怎么见过的用法了,在C语言的宏中，#的功能是将其后面的宏参数进行字符串化操作(Stringfication)，把随后的token(标识符,或者说变量名)转化为C语言的字符串,简单说就是将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define EXAMPLE(instr) printf(&amp;#34;The input string is:%s\n&amp;#34;, #instr)&#xA;#define EXAMPLE2(instr) #instr&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;EXAMPLE(Hello);会展开为printf(&amp;ldquo;The input string is:%s\n&amp;rdquo;,&amp;ldquo;Hello&amp;rdquo;);&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;忽略传入参数名前面和后面的空格。&lt;/li&gt;&#xA;&lt;li&gt;当传入参数名间存在多个空格时，编译器会自动连接各个子字符串，每个子字符串间只以一个空格连接。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;符号连接操作符&#34;&gt;符号连接操作符##&lt;/h3&gt;&#xA;&lt;p&gt;##运算符(Token Pasting Operator)连接两个token为一个token,即将两个变量名合成一个变量名.&#xA;例子:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define LINK(A,B) A##B&#xA;int ab =9;&#xA;printf(&amp;#34;%d&amp;#34;,LINK(a,b));&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果就是9&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
