<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>网络编程 on huolong blog</title>
    <link>http://localhost:1313/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 网络编程 on huolong blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Feb 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HTTP详解</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h3 id=&#34;http协议初相识&#34;&gt;HTTP协议初相识&lt;/h3&gt;&#xA;&lt;p&gt;HTTP协议(超文本传输协议),将超文本标记语言(HTML)从Web服务器传送到客户端,属于应用层协议,目前使用的HTTP协议基本都是基于TCP协议的。&#xA;超文本:文本中存在超链接可以进行跳转&#xA;HTTP协议的几次版本更迭:&#xA;HTTP0.9 -&amp;gt; HTTP1.0 -&amp;gt; HTTP1.1(目前所用最多的版本) -&amp;gt; HTTP2.0 -&amp;gt; HTTP3.0(仍处于概念阶段,基于QUIC协议)&lt;/p&gt;&#xA;&lt;p&gt;TCP的三次握手:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第一次连接:客户端发送带有SYN标志(同步序列编号,是TCP/IP建立连接时使用的握手信号)的连接请求报文段,然后进入SYN-SEND状态,等待服务端的确认。&lt;/li&gt;&#xA;&lt;li&gt;第二次连接:服务端接收到客户端的SYN报文后会发送一个ACK信息进行确认,同时会发送一个SYN报文给客户端,SYN和ACK会放到一个报文段中,一并发送给客户端,此时服务端进入SYN_RECV状态。&lt;/li&gt;&#xA;&lt;li&gt;第三次连接:客户端收到后,会向服务器端发送一个ACK确认报文段,发送完毕后,客户端和服务端都进入ESTABLISHED状态,三次握手完成。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;三次握手的目的是确认双方的收发能力正常,更具体可以理解为双方都知道自己和对方的收发功能正常,三次恰好能完美地验证彼此收发功能是否正常。&lt;/p&gt;&#xA;&lt;p&gt;HTTP处理过程概述:&#xA;DNS查询以获得IP地址-&amp;gt;三次握手建立TCP连接-&amp;gt;发送HTTP请求&lt;/p&gt;&#xA;&lt;h3 id=&#34;http协议再入门&#34;&gt;HTTP协议再入门&lt;/h3&gt;&#xA;&lt;p&gt;HTTP协议的特点:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用C/S模式,由客户端向服务器发出请求,服务器做出应答&lt;/li&gt;&#xA;&lt;li&gt;简单快速,客户端发送请求时,只需要传送请求方法和路径&lt;/li&gt;&#xA;&lt;li&gt;灵活,可以传输多种类型的数据对象,传输内容类型由content-type标识&lt;/li&gt;&#xA;&lt;li&gt;无连接,限制每次连接只处理一个请求,即服务器处理完客户的请求并收到应答后会断开连接,后续发展出长连接(keep-alive)&lt;/li&gt;&#xA;&lt;li&gt;无状态,如果后续处理需要之前发送的信息,则需要重新传输,后续发展出了cookie和session部分解决了这个问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;补充一下URL和URI的区别&#xA;URI可以分为URL和URN,URN确定了东西的身份,URL提供了找到它的方式&#xA;URL是URI的一种,但并非所有URI都是URL&#xA;URI和URL最大的区别在于&amp;quot;访问机制&amp;quot;&#xA;&lt;a href=&#34;https://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;是URI,加上 http:// 后才能称为URL&lt;/p&gt;&#xA;&lt;p&gt;HTTP请求报文常用参数分析&lt;/p&gt;&#xA;&lt;p&gt;HTTP请求报文由以下四部分组成:请求行,请求头,空行,请求体(GET请求没有)&lt;/p&gt;&#xA;&lt;p&gt;响应行由请求方法、URL和HTTP协议版本3个字段组成,它们用空格分隔。比如:GET /index.html HTTP/1.1&lt;/p&gt;&#xA;&lt;p&gt;请求头的参数:&#xA;Accept:浏览器端可以接受的媒体类型,比如text/html表示接受html文档,如果服务器没有此类型资源可以返回,会返回406错误。ACCEPT:*/*表示浏览器可以处理所有类型&#xA;Accept-Encoding:浏览器申明自己接收的编码方式,通常指定压缩方法,是否支持压缩,支持什么压缩方法(gzip,deflate)&lt;br&gt;&#xA;Accept-Language:申明自己接收的语言,比如zh-CN表示中文。&#xA;Connection:表示连接状态,当该值为keep-alive时表示底层的TCP连接不会断开,客户端再次访问时会继续使用这条已建立的连接,参数值为close时,则表示需要重新建立TCP连接&#xA;Host:表示服务器的Internet主机和端口号&#xA;Referer:告诉服务器客户端是由哪个页面链接过来的&#xA;User-Agent:告诉Http服务器,客户端使用的浏览器类型和操作系统&#xA;Content-Type:说明报文内对象的媒体类型,比如:text/html和image/png&lt;/p&gt;&#xA;&lt;p&gt;HTTP响应报文与请求报文类似,大多数参数代表意义相同,分为响应行,响应头,空行,响应体四部分.&#xA;响应行由协议版本,状态码和状态描述三部分组成,比如:HTTP/1.1 200 OK&lt;/p&gt;&#xA;&lt;p&gt;HTTP请求方法详解:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;GET方法:用来请求访问已被URI标识的资源,提交数据量小,提交的信息直接包含在URL当中,也可以用来提交表单等数据,但一般并不这么做&lt;/li&gt;&#xA;&lt;li&gt;POST方法:POST方法的主要目的一般并非获取内容,而是提交数据,提交的数据被放在报文的请求体中,克服了GET方法中无法保密和数据量太小等缺点&lt;/li&gt;&#xA;&lt;li&gt;PUT方法:与POST方法十分类似,用于向服务器发送数据取代指点的原有内容,因为安全性上的缺陷,基本不用&lt;/li&gt;&#xA;&lt;li&gt;HEAD方法:类似于GET方法,只不过返回的结果没有具体内容,用于获取报头&lt;/li&gt;&#xA;&lt;li&gt;DELETE方法:请求删除指定资源,因为缺少一些验证机制,现在在一个网站中发现可以使用DELETE方法基本就是发现了漏洞&lt;/li&gt;&#xA;&lt;li&gt;OPTIONS方法:用来查询针对请求URI指定资源支持的方法&lt;/li&gt;&#xA;&lt;li&gt;TRACE方法:用来回显服务器收到的请求,用于测试和诊断,易引起攻击,很少使用&lt;/li&gt;&#xA;&lt;li&gt;CONNECT方法:开启一个客户端与所请求资源之间的通道,用在HTTP代理&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP状态码详解:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1XX:表示请求已被接受但是需要继续处理,这类响应是临时响应,只包含响应行和部分响应头信息,以空行结束,很少使用&lt;/li&gt;&#xA;&lt;li&gt;2XX:表示成功,即请求已经成功被服务器接收,理解,接受&#xA;常用的有:200 OK(接受并已处理),202 Accepted(接受但并未处理),206 Partial Content(请求部分内容)&lt;/li&gt;&#xA;&lt;li&gt;3XX:表示重定向,重定向目标会在本次响应的Location域中指明&#xA;常用的有:301 Moved Permanently(永久移动),302 Found(临时跳转),304 Not Modified(资源尚未修改,请使用缓存)&lt;/li&gt;&#xA;&lt;li&gt;4XX:表示请求错误&#xA;常用:400 Bad Request,401 Unauthorized,403 Forbidden,404 Not Found&lt;/li&gt;&#xA;&lt;li&gt;5XX:表示服务器错误&#xA;常用:500 Internal Server Error,502 Bad Gateway(充当网关或代理服务器,从远端服务器接收到一个无效请求)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;HTTP的状态管理:cookie和session&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java网络编程</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h3 id=&#34;url解析&#34;&gt;url解析&lt;/h3&gt;&#xA;&lt;p&gt;当我们在浏览器内输入一段网址的时候,比如 &lt;a href=&#34;http://www.google.com&#34;&gt;http://www.google.com&lt;/a&gt; 进行访问的时候,真实发送出去的可能并非如此,可能是&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.google.com:80/search?q=test&amp;amp;safe=strict&#34;&gt;http://www.google.com:80/search?q=test&amp;amp;safe=strict&lt;/a&gt;&#xA;协议   域名/IP地址    端口 路径   问号后为参数&lt;/p&gt;&#xA;&lt;h3 id=&#34;dns解析domain-name-system&#34;&gt;DNS解析(Domain Name System)&lt;/h3&gt;&#xA;&lt;p&gt;如果我们要访问谷歌,只需要输入域名或者IP(这个一般没人会去做)就好了,但是谷歌是相当大的,不可能只有一台服务器,我们是怎么找到它其中一台服务器的哪?这就用到了DNS解析.即将输入的域名解析为IP地址.为了说清楚域名解析的过程,我们来看看域名都包含哪些东西:&#xA;&lt;a href=&#34;https://www.google.com&#34;&gt;www.google.com&lt;/a&gt;.&#xA;. 根域名&#xA;.com  顶级域名(还有.org .edu等)&#xA;.google 次级域名(这个就比较自由了,依照自己需要发挥)&#xA;此处没有三级域名   三级域名&#xA;www  主机名(根据需求可变比如:news.163.com)&#xA;DNS解析方法主要有两种:递归和迭代&#xA;大体方向:浏览器-&amp;gt;dns客户端(本地程序)-&amp;gt;各级DNS服务器&#xA;另外一个域名是可以对应一个或多个IP的&lt;/p&gt;&#xA;&lt;h3 id=&#34;各级协议&#34;&gt;各级协议&lt;/h3&gt;&#xA;&lt;p&gt;真实网络层级分为5层(OSI七层是模型,因某些原因真实情况并不是7层):&lt;/p&gt;&#xA;&lt;p&gt;应用层(用户所接触到的应用对数据处理格式)&#xA;传输层(端口到端口的连接,同一主机上有许多程序被分配了不同的端口)&#xA;网络层(主机到主机之间的联系,发送地到目的地)&#xA;数据链路层(网卡和网卡之间信息传输,关系到mac地址,传输信息采用广播这种比较原始的方法)&#xA;物理层(过于底层,真实的物理连接,电缆光缆等等)&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;分层思想(计组第一章内容)使得大家能够各司其职,在本层做出改动只要不影响向上一层的接口,那么对于上一层来说就没有影响。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;每一层有每一层使用的协议(即数据组织格式),举例来说:&lt;/p&gt;&#xA;&lt;p&gt;应用层协议: HTTP协议(传输网页内容) SMTP(收发邮件) FTP(文件传输) DNS(域名解析)&lt;/p&gt;&#xA;&lt;p&gt;传输层协议: TCP协议(较为可靠,但是比较繁琐) UDP(不太可靠,相对简单)&lt;/p&gt;&#xA;&lt;p&gt;网络层协议: IP协议(每个主机都有一个IP)&lt;/p&gt;&#xA;&lt;p&gt;数据链路层协议: Ethernet协议 ARP(IP地址和mac地址转换)&lt;/p&gt;&#xA;&lt;p&gt;物理层: 电信号(一般没人到这步吧&amp;hellip;.)&lt;/p&gt;&#xA;&lt;p&gt;协议格式简述:&#xA;&lt;img src=&#34;protocol.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;web基础概念&#34;&gt;Web基础概念&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件架构&#xA;C/S类型:客户端/服务器端&amp;ndash;&amp;gt; QQ,360客户端&#xA;B/S类型:浏览器/服务器端&amp;ndash;&amp;gt; 各种网站&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;资源分类&#xA;静态资源:所有用户访问时得到的结果都是一样的,静态资源可以直接被浏览器解析。比如:html,css,jpg等等&#xA;动态资源:不同用户访问得到的结果可能是不一样的,浏览器无法被浏览器直接解析,必须经过服务器端处理后转换为静态资源返回给浏览器才能解析。比如:php,asp,jsp等等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;CSArch.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;网络通信三要素&#xA;IP:计算机在网络中的唯一标识&#xA;端口:应用程序监听的端口在计算机中是唯一的&#xA;传输协议:规定了数据传输的格式,比如TCP,UDP,HTTP协议&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;常见的web服务器&#xA;服务器:安装了服务器软件的计算机&#xA;服务器软件:接收用户的请求,处理请求做出回应&#xA;web服务器软件:tomcat,weblogic等等&lt;/p&gt;</description>
    </item>
    <item>
      <title>爬虫原理</title>
      <link>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;h3 id=&#34;什么是爬虫&#34;&gt;什么是爬虫&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;爬虫是请求网站提取数据的自动化程序&lt;/code&gt;&#xA;关键点:1.发送请求(HTTP请求)2.获取服务器响应的内容(HTML代码,Json字符串,二进制数据等)3.解析内容4.保存数据&lt;/p&gt;&#xA;&lt;h3 id=&#34;发送请求&#34;&gt;发送请求&lt;/h3&gt;&#xA;&lt;p&gt;我们在向服务器端发送的Request中包含哪些东西呢?&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;请求方式:主要是GET和POST两种请求方法,还有一些HEAD,PUT,DELETE等等。&lt;/li&gt;&#xA;&lt;li&gt;请求URL:URL的全程是统一资源定位符,一个网页文档,一个视频,一张图片都可以由此确定,浏览器在渲染网页过程中会使用到URL。&lt;/li&gt;&#xA;&lt;li&gt;请求头:包含了一些请求时需要的配置信息,比如User-Agent,Cookies等等.服务器会依据这些信息来判断请求是否合法&lt;/li&gt;&#xA;&lt;li&gt;请求体:在做POST请求时会需要请求体这一部分,以键值对的形式发送。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;服务器响应&#34;&gt;服务器响应&lt;/h3&gt;&#xA;&lt;p&gt;Response中包含哪些内容:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;状态码(标识响应状态):200(请求成功),404(请求的资源不存在),301(重定位),502(服务器处理错误)&lt;/li&gt;&#xA;&lt;li&gt;响应头:保存内容类型,内容长度,服务器信息,设置cookie等等.&lt;/li&gt;&#xA;&lt;li&gt;响应体:最主要部分,包含了请求的资源,比如图片,网页源代码等等.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;解析内容&#34;&gt;解析内容&lt;/h3&gt;&#xA;&lt;p&gt;可以通过JSON解析,正则表达式解析,利用python解析库来进行解析&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;为什么抓取的数据和浏览器中看到的不一样呢?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;浏览器会将拿到的数据进行渲染,故会有很大不同,为了解决这一问题,我们可以分析Ajax请求,利用webdriver等库来自动化操作浏览器,调用splash库来进行js渲染等.&lt;/p&gt;&#xA;&lt;h3 id=&#34;保存数据&#34;&gt;保存数据&lt;/h3&gt;&#xA;&lt;p&gt;可以存取为纯文本,图片,音视频,或者存到数据库中&lt;/p&gt;&#xA;&lt;h3 id=&#34;什么是正则表达式&#34;&gt;什么是正则表达式&lt;/h3&gt;&#xA;&lt;p&gt;正则表达式是对字符串操作的一种逻辑公式,由普通字符（例如字符a到z）以及特殊字符（称为&amp;quot;元字符&amp;quot;）组成文字模式,模式描述在搜索文本时要匹配的一个或多个字符串,正则表达式作为一个模板,将某个字符模式与所搜索的字符串进行匹配。&lt;/p&gt;&#xA;&lt;h3 id=&#34;正则表达式在爬虫编写中的作用&#34;&gt;正则表达式在爬虫编写中的作用&lt;/h3&gt;&#xA;&lt;p&gt;通过正则表达式提取出网页中的有用信息,是爬虫程序最原始最灵活的写法,后续衍生出了无穷多的变体.&lt;/p&gt;&#xA;&lt;h3 id=&#34;常见匹配模式&#34;&gt;常见匹配模式&lt;/h3&gt;&#xA;&lt;p&gt;\w 匹配字母数字及下划线&#xA;\W 匹配非字母数字下划线&#xA;\s 匹配空白字符,等价于[\t\n\r\f]&#xA;\S 匹配非空白字符&#xA;\d 匹配数字,等价于[0-9]&#xA;\D 匹配任意非数字&#xA;^ 匹配字符串的开头&#xA;$ 匹配字符串的末尾&#xA;. 匹配任意除换行符以外的字符&#xA;[&amp;hellip;] 匹配中括号中包含的字符&#xA;[^&amp;hellip;] 匹配除中括号包含的字符以外的任意字符&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匹配0个或多个表达式,贪婪匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;匹配1个或多个表达式,贪婪匹配&#xA;? 匹配0个或者1个字符,非贪婪匹配&#xA;{n} 匹配n个前面的表达式.&#xA;{n,m} 匹配n次到m次前面的表达式,贪婪匹配&#xA;a|b 匹配a或b&#xA;() 匹配括号内的表达式,也表示一个组&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
