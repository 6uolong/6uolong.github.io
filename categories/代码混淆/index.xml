<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>代码混淆 on huolong blog</title>
    <link>https://6uolong.github.io/categories/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</link>
    <description>Recent content in 代码混淆 on huolong blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 25 Oct 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://6uolong.github.io/categories/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于雪崩猜想的混淆构造</title>
      <link>https://6uolong.github.io/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%9F%BA%E4%BA%8E%E9%9B%AA%E5%B4%A9%E7%8C%9C%E6%83%B3%E7%9A%84%E6%B7%B7%E6%B7%86%E6%9E%84%E9%80%A0/</link>
      <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%9F%BA%E4%BA%8E%E9%9B%AA%E5%B4%A9%E7%8C%9C%E6%83%B3%E7%9A%84%E6%B7%B7%E6%B7%86%E6%9E%84%E9%80%A0/</guid>
      <description>&lt;h2 id=&#34;符号执行&#34;&gt;符号执行&lt;/h2&gt;&#xA;&lt;p&gt;定义：一种程序分析技术，采用抽象的符号代替精确值作为程序输入变量，通过约束求解器得出每个路径抽象的输出结果。（解方程）&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;静态符号执行：不执行程序，将所有输入符号化。&lt;/li&gt;&#xA;&lt;li&gt;动态（混合）符号执行：尽可能地执行程序，尽可能少地引入符号变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;分析流程大致如下：&#xA;&lt;img src=&#34;%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;极简示例&#34;&gt;极简示例&lt;/h3&gt;&#xA;&lt;p&gt;将下列C++源代码编译，并用符号执行框架angr进行分析。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&amp;lt;iostream&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; choice;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; choice;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(choice &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right path&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wrong path&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;找到right path的约束条件为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;In [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]: simgr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;explore(find&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x401208&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Out[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]: &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;SimulationManager &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; active, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; found&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;In [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]: simgr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;found[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;solver&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;constraints&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Out[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]: [&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Bool (LShR((condition_56_32), &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1f&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;LShR操作表示逻辑右移，化简该条件可知约束为choice &amp;gt;= 0&lt;/p&gt;&#xA;&lt;h3 id=&#34;符号执行框架组成&#34;&gt;符号执行框架组成&lt;/h3&gt;&#xA;&lt;p&gt;符号执行框架有很多，常用的有angr、klee、triton这三个。它们大都由以下几部分组成：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;文件加载器&lt;/li&gt;&#xA;&lt;li&gt;中间语言转换接口&lt;/li&gt;&#xA;&lt;li&gt;约束求解器（比如z3）&lt;/li&gt;&#xA;&lt;li&gt;模拟执行引擎（动态分析需要）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;angr框架v9238&#34;&gt;angr框架（v9.2.38）&lt;/h3&gt;&#xA;&lt;p&gt;angr是一个支持多架构的二进制文件动态符号执行分析工具&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;simgr.use_technique&lt;/td&gt;&#xA;          &lt;td&gt;simgr.explore&lt;/td&gt;&#xA;          &lt;td&gt;simgr.step&lt;/td&gt;&#xA;          &lt;td&gt;simgr.run&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;在分析过程中使用指定的分析方法（默认为广度优先搜索）。&lt;/td&gt;&#xA;          &lt;td&gt;接收一个地址，输出到达该地址时程序的状态（默认找到一条路径就返回）。&lt;/td&gt;&#xA;          &lt;td&gt;以块或函数为最小单位模拟执行一步。&lt;/td&gt;&#xA;          &lt;td&gt;按照设定的分析方法执行直到分析完毕。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;angr中常用的约束收集策略如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>从零开始的MBA混淆(1)</title>
      <link>https://6uolong.github.io/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84mba%E6%B7%B7%E6%B7%861/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84mba%E6%B7%B7%E6%B7%861/</guid>
      <description>&lt;h2 id=&#34;mba运算&#34;&gt;MBA运算&lt;/h2&gt;&#xA;&lt;p&gt;MBA运算（Mixed Boolean-Arithmetic）是一种定义在模$2^n$下的混合了布尔逻辑运算（与&amp;amp;、或|、非~、异或^）和代数运算（+、-、*、/）的运算系统。以下为一个C语言实现的MBA运算示例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, b;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; b) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; b); &lt;span style=&#34;color:#75715e&#34;&gt;// 等价于c=a+b&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线性mba&#34;&gt;线性MBA&lt;/h2&gt;&#xA;&lt;p&gt;线性MBA常用于运算混淆中，它的定义如下：&#xA;$$&#xA;\sum_{i \in I}a_i e_i (x_1,x_2,&amp;hellip;,x_t)&#xA;$$&#xA;其中$a_i$为整数，$e_i(x_1,x_2,&amp;hellip;,x_n)$为只含有布尔逻辑运算的表达式，简单举几个例子，以下的表达式都属于线性MBA：&#xA;$$&#xA;f(x,y) = (x \lor y) - (x \land y) - (x \oplus y)&#xA;\newline&#xA;f(x,y) = x-3*(x \land y)-(x \oplus y)+(\lnot y)-(\lnot(x \land y)) + 2*y&#xA;$$&lt;/p&gt;&#xA;&lt;h3 id=&#34;位独立性&#34;&gt;位独立性&lt;/h3&gt;&#xA;&lt;p&gt;线性MBA的特点是具有位独立性，即由加号相连接的每一项，只含有布尔逻辑运算，变量的每一位的运算不会影响到前一位或后一位，这就是位独立性。以int类型的变量举例来说：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; y &lt;span style=&#34;color:#75715e&#34;&gt;// 01 + 01 = 10 低位向高位进位&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; y &lt;span style=&#34;color:#75715e&#34;&gt;// 01 &amp;amp; 01 = 01 不会存在进位&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;位独立性保证了每一位的运算规律相同，使得我们可以将变量的取值空间由32bit缩小至1bit，在1bit空间对变量的取值进行枚举来构造线性MBA等式，例如：&lt;/p&gt;</description>
    </item>
    <item>
      <title>位操作杂项</title>
      <link>https://6uolong.github.io/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://6uolong.github.io/posts/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%9D%82%E9%A1%B9/</guid>
      <description>&lt;h3 id=&#34;移位和乘除法&#34;&gt;移位和乘除法&lt;/h3&gt;&#xA;&lt;p&gt;移位分为左移、逻辑右移、算术右移三种，他们和乘除法有着很密切的关系：&#xA;x &amp;laquo; n 等价于 x * 2^n，算术右移是除以2后向下取整，整除在C语言中是向0取整，在python中则是向下取整。&#xA;以C语言转为的汇编为例，除2^n的算术经常优化为右移运算加符号位：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;movl &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;ecx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sarl &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;ecx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;movl &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;edx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;shrl &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;edx &lt;span style=&#34;color:#75715e&#34;&gt;// fix: %edx=(%edx&amp;lt;0?1:0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;addl &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;edx,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax &lt;span style=&#34;color:#75715e&#34;&gt;// fix: add one if a&amp;lt;0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;sarl &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;eax&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;无溢出的平均数求法&#34;&gt;无溢出的平均数求法&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ((x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// sum == carries + sum_without_carries&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;y) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ((x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要特别注意在C语言中，(x+y)/2 != x/2+y/2，等号只有在x，y中有任意一个为偶数的时候成立。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ((x&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;y)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ceil_average(x,y) == average(x,y) + ((x^y)&amp;amp;1))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;((x+y - x|y)&amp;laquo;1) == x+y-(x^y)&#xA;(x+y) == (x|y)&amp;laquo;1 - (x^y) &#xA;x+y = (x&amp;amp;y)*2 + x^y&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
